
{{DEVELOPMENT}} --------(((DEBUGINFO)))--------{{DEVELOPMENT}} 

 DRIVER SYMBOLS (alphabet order)
-------------------------------
Abstract=Common\AsynchroSerialAbstract.inc
BRFA1=0
CommonHCS08Subroutines=
DataLength=1
DataType=byte
DefineInpBufSize=Terminal_INP_BUF_SIZE
DefineOutBufSize=Terminal_OUT_BUF_SIZE
Description_HWEnDi=Enables or disables the peripheral(s) associated with the component. The method is called automatically as a part of the Enable and Disable methods and several internal methods.
Description_Init=Initializes the associated peripheral(s) and the component's internal variables. The method is called automatically as a part of the application initialization code.
Description_InterruptCs=The method services the interrupt caused byt CTS input and re-enables the transmission.
Description_InterruptError=The method services the error interrupt of the selected peripheral(s) and eventually invokes the component's event(s).
Description_InterruptRx=The method services the receive interrupt of the selected peripheral(s) and eventually invokes the component's event(s).
Description_InterruptTx=The method services the transmit interrupt of the selected peripheral(s) and eventually invokes the component's event(s).
Description_SetHigh=The method reconfigures the component and its selected peripheral(s) when the CPU is switched to the High speed mode. The method is called automatically as s part of the CPU SetHighSpeed method.
Description_SetLow=The method reconfigures the component and its selected peripheral(s) when the CPU is switched to the Low speed mode. The method is called automatically as a part of the CPU SetLowSpeed method.
Description_SetSlow=The method reconfigures the component and its selected peripheral(s) when the CPU is switched to the Slow speed mode. The method is called automatically as a part of the CPU SetSlowSpeed method.
Doc_Misra_Rule_1=1.1
Doc_Misra_Rule_10=12.4
Doc_Misra_Rule_10_Description=The right-hand operand of a logical && or || operator shall not contain side effects.
Doc_Misra_Rule_10_Lint=Note 960: Violates MISRA 2004 Required Rule 12.4, side effects on right hand of logical operator
Doc_Misra_Rule_10_Reason=See detailed description for particular component
Doc_Misra_Rule_10_Type=Required
Doc_Misra_Rule_11=12.10
Doc_Misra_Rule_11_Description=The comma operator shall not be used.
Doc_Misra_Rule_11_Lint=Note 960: Violates MISRA 2004 Required Rule 12.10, comma operator used
Doc_Misra_Rule_11_Reason=Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled only for 'Generate macros = yes'  option (Build Options)
Doc_Misra_Rule_11_Type=Required
Doc_Misra_Rule_12=14.2
Doc_Misra_Rule_12_Description=All non-null statements shall either: <br/>a) have at least one side effect however executed, <br/>or b) cause control flow to change.
Doc_Misra_Rule_12_Lint=Warning 522: Highest operation, function 'string', lacks side-effects [MISRA 2004 Rule 14.2]
Doc_Misra_Rule_12_Reason=PC-lint reports the warning for functions, which are wrappers for inline asm block (asm block is ignored by PC-lint).
Doc_Misra_Rule_12_Type=Required
Doc_Misra_Rule_13=14.3
Doc_Misra_Rule_13_Description=A null statement shall only occur on a line by itself
Doc_Misra_Rule_13_Lint=Note 960: Violates MISRA 2004 Required Rule 14.3, null statement not in line by itself
Doc_Misra_Rule_13_Reason=Several inline asm instructions are in one line separated by semicolon (asm() is ignored by PC-lint).
Doc_Misra_Rule_13_Type=Required
Doc_Misra_Rule_14=14.7
Doc_Misra_Rule_14_Description=A function shall have a single point of exit at the end of the function.
Doc_Misra_Rule_14_Lint=Note 904: Return statement before end of function [MISRA 2004 Rule 14.7]
Doc_Misra_Rule_14_Reason=Use of multiple return statements simplifies the code logic.
Doc_Misra_Rule_14_Type=Required
Doc_Misra_Rule_15=16.7
Doc_Misra_Rule_15_Description=A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object.
Doc_Misra_Rule_15_Lint=Info 818: Pointer parameter could be declared as pointing to const [MISRA 2004 Rule 16.7]
Doc_Misra_Rule_15_Reason=See reasons specified for each component
Doc_Misra_Rule_15_Type=Advisory
Doc_Misra_Rule_16=16.8
Doc_Misra_Rule_16_Description=All exit paths from a function with non-void return type shall have an explicit return statement with an expression.
Doc_Misra_Rule_16_Lint=Warning 533: function should return a value [MISRA 2004 Rule 16.8]
Doc_Misra_Rule_16_Reason=Function contains inline assembler instructions to get value of pin not associated with any port.
Doc_Misra_Rule_16_Type=Required
Doc_Misra_Rule_17=18.4
Doc_Misra_Rule_17_Description=Unions shall not be used.
Doc_Misra_Rule_17_Lint=Note 960: Violates MISRA 2004 Required Rule 18.4, unions shall not be used
Doc_Misra_Rule_17_Reason=Unions are used to efficiently swap bytes in a word or long word, to allow simple access to bit-field and to allow access to bits of registers for peripheral modules.
Doc_Misra_Rule_17_Type=Required
Doc_Misra_Rule_18=19.7
Doc_Misra_Rule_18_Description=A function should be used in preference to a function-like macro.
Doc_Misra_Rule_18_Lint=Note 961: Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined
Doc_Misra_Rule_18_Reason=Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros' = yes option (Build Options).
Doc_Misra_Rule_18_Type=Advisory
Doc_Misra_Rule_19=19.12
Doc_Misra_Rule_19_Description=There shall be at most one occurrence of the # or ## preprocessor operators in a single macro definition.
Doc_Misra_Rule_19_Lint=Note 960: Violates MISRA 2004 Required Rule 19.12, Multiple use of '#/##' operators in macro definition
Doc_Misra_Rule_19_Reason=Multiple occurrences of preprocessor operators are used to convert bit name to bit mask in macros for accessing peripheral registers.
Doc_Misra_Rule_19_Type=Required
Doc_Misra_Rule_1_Description=All code shall conform to ISO 9899-1990 (C-code guideline)
Doc_Misra_Rule_1_Lint=Note 950: Non-ANSI reserved word or construct [MISRA 2004 Rules 1.1 and 2.2]
Doc_Misra_Rule_1_Reason=Non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt, CONVERT_TO_PAGED (RS08 only).
Doc_Misra_Rule_1_Type=Required
Doc_Misra_Rule_2=1.2
Doc_Misra_Rule_20=19.13
Doc_Misra_Rule_20_Description=The # and ## preprocessor operators should not be used.
Doc_Misra_Rule_20_Lint=Note 961: Violates MISRA 2004 Advisory Rule 19.13, '#/##' operator used
Doc_Misra_Rule_20_Reason=Preprocessor operators are used to convert bit name to bit mask in macros for accessing peripheral registers.
Doc_Misra_Rule_20_Type=Advisory
Doc_Misra_Rule_21=19.15
Doc_Misra_Rule_21_Description=Precautions shall be taken in order to prevent the contents of a header file being included twice.
Doc_Misra_Rule_21_Lint=Warning 537: Repeated include file 'PE_Types.h' [MISRA 2004 Rule 19.15]
Doc_Misra_Rule_21_Reason=All generated header files contain associated macro, which definition is tested. The headers file's content is included only if the macro is not defined.
Doc_Misra_Rule_21_Type=Required
Doc_Misra_Rule_2_Description=No reliance shall be placed on undefined or unspecified behavior
Doc_Misra_Rule_2_Lint=See lint message for specific component.
Doc_Misra_Rule_2_Reason=See specific reasons for each component.
Doc_Misra_Rule_2_Type=Required
Doc_Misra_Rule_3=2.4
Doc_Misra_Rule_3_Description=Sections of code should not be 'commented out'.
Doc_Misra_Rule_3_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_3_Reason=Each init component contains 'Commented out' example of interrupt service routine (ISR), if generation of the ISR is enabled.
Doc_Misra_Rule_3_Type=Advisory
Doc_Misra_Rule_4=5.1
Doc_Misra_Rule_4_Description=Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
Doc_Misra_Rule_4_Lint=Warning 621: Identifier clash [MISRA 2004 Rules 1.2, 1.4 and 5.1]
Doc_Misra_Rule_4_Reason=Length of register identifiers of peripheral modules are sometimes longer than 31 characters to comply with the Reference Manual.
Doc_Misra_Rule_4_Type=Required
Doc_Misra_Rule_5=6.4
Doc_Misra_Rule_5_Description=Bit-field shall only be defined to be of type unsigned int or signed int.
Doc_Misra_Rule_5_Lint=Error 46: field type should be int, unsigned int or signed int [MISRA 2004 Rule 6.4]
Doc_Misra_Rule_5_Reason=Unsigned char type is used in bit-fields as smallest possible type.
Doc_Misra_Rule_5_Type=Required
Doc_Misra_Rule_6=8.10
Doc_Misra_Rule_6_Description=All declarations and definitions of objects or function at file scope shall have internal linkage unless external linkage is required.
Doc_Misra_Rule_6_Lint=Info 765: external 'function' could be made static [MISRA 2004 Rule 8.10]
Doc_Misra_Rule_6_Reason=Device Initialization - ISR declaration is subject of various modifications by the user and may or may not be copied to another module - static is not used.
Doc_Misra_Rule_6_Type=Required
Doc_Misra_Rule_7=10.3
Doc_Misra_Rule_7_Description=The value of a complex expression of integer type may only be cast to a type that is narrower and of the same signedness as the underlying type of the expression.
Doc_Misra_Rule_7_Lint=Note 960: Violates MISRA 2004 Required Rule 10.3, Cast of complex expression changes signedness
Doc_Misra_Rule_7_Reason=For IRTC peripheral module, the value of a year in the register is represented by a signed value, but the interface of the component uses unsigned value. Typecast of na expression to unsigned value is used due to less code size.
Doc_Misra_Rule_7_Type=Required
Doc_Misra_Rule_8=11.3
Doc_Misra_Rule_8_Description=A cast should not be performed between a pointer type and an integral type.
Doc_Misra_Rule_8_Lint=Note 923: cast from 'integer type' to pointer [Encompasses MISRA 2004 Rules 11.1 and 11.3], [MISRA 2004 Rule 11.3]
Doc_Misra_Rule_8_Reason=See detailed description for particular component
Doc_Misra_Rule_8_Type=Advisory
Doc_Misra_Rule_9=11.4
Doc_Misra_Rule_9_Description=A cast should be not be performed between a pointer to object type and different pointer to object type
Doc_Misra_Rule_9_Lint=Note 929: cast from pointer to pointer [MISRA 2004 Rule 11.4]
Doc_Misra_Rule_9_Reason=See detailed description for particular component
Doc_Misra_Rule_9_Type=Required
DriverAuthor=Marek Vinkler / Marek Neuzil
DriverDate=03.02.2003
DriverVersion=01.33
EnCommonErr=
EnEvent=
EnUser=
EndOfInterface=
GenEnDiMacros=
GenGetCharsInRxBufMacro=
GenGetCharsInTxBufMacro=
InitPrescalerInternPresc=no
ParChr=
ParPtr=
ParRcv=
ParSize=
ParSnd=
ReceiverUsed=
RegType=byte
RegWidth=8
ReplaceConstants=
ResultMask=OVERRUN_ERR|COMMON_ERR|FULL_RX
RetVal=
SBRpresc=27
SerFlagEn=
SerFlagMask=COMMON_ERR
SerFlagType=byte
SerFlagTypeModifier=volatile 
Settings=Common\AsynchroSerialSettings.inc
Stat2Reg=0
Thread_SimpleService=
TransmitterUsed=
c1=5
c2=5
divH1=0
divL1=27
length=15
nastav1=0
temp=0
temp2=6
tempComment= Disable receiver, Disable transmitter, Disable transmit interrupt, Disable receiver interrupt
tempName=(byte)(~(byte)SCI1C2_RE_MASK) & (byte)(~(byte)SCI1C2_TE_MASK) & (byte)(~(byte)SCI1C2_TIE_MASK) & (byte)(~(byte)SCI1C2_RIE_MASK)
tmp=27
ABECEDA=[A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z]
Doc_Misra_Rule_10_Location=[Cpu|AsynchroSerial|ADC|Cpu|AsynchroSerial|ADC]
Doc_Misra_Rule_10_Location_Reason=[In Device Initialization for RS08 derivatives that supports interrupt vector, in ISR dispatcher two status register are scanned in one while condition using || operator. Short evaluation of a condition is not important, because the ISR dispatcher scans the variables in the loop.|The code is accessing two volatile varibles in a condition. The order of access to variables is not important, because the variables are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|The code is accessing a register and a volatile varible in a condition. The order of access is not important, because the variable and register are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|In Device Initialization for RS08 derivatives that supports interrupt vector, in ISR dispatcher two status register are scanned in one while condition using || operator. Short evaluation of a condition is not important, because the ISR dispatcher scans the variables in the loop.|The code is accessing two volatile varibles in a condition. The order of access to variables is not important, because the variables are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|The code is accessing a register and a volatile varible in a condition. The order of access is not important, because the variable and register are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.]
Doc_Misra_Rule_11_Location=[Global|WatchDog|Global|WatchDog]
Doc_Misra_Rule_11_Location_Reason=[Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled for 'Generate macros = yes' option (Build Options)|Comma operator is used in 'Clear' macro (optimization for code size). The rule is disabled for 'Generate macros = no' option (Build Options)|Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled for 'Generate macros = yes' option (Build Options)|Comma operator is used in 'Clear' macro (optimization for code size). The rule is disabled for 'Generate macros = no' option (Build Options)]
Doc_Misra_Rule_12_Location=[Cpu|SW_I2C|InternalI2C|Init_SAW|Cpu|SW_I2C|InternalI2C|Init_SAW]
Doc_Misra_Rule_12_Location_Reason=[PC-lint reports the warning for 'Delay100US' method, which is a wrapper for inline asm block (asm block is ignored by PC-lint);<br/>PC-lint may report the warning in Device Initialization for RS08 derivatives that supports interrupt vector. In interrupt service routine, empty sub-routines templates for each peripheral interrupt are called.|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay100US' method, which is a wrapper for inline asm block (asm block is ignored by PC-lint);<br/>PC-lint may report the warning in Device Initialization for RS08 derivatives that supports interrupt vector. In interrupt service routine, empty sub-routines templates for each peripheral interrupt are called.|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).]
Doc_Misra_Rule_13_Location=[PE_Types.h|PE_Types.h]
Doc_Misra_Rule_14_Location=[Global|Global]
Doc_Misra_Rule_15_Location=[IntFlash|IntFlash]
Doc_Misra_Rule_15_Location_Reason=['Source' parameter of SetBlockFlash method can be declared as const but only in specific component's setting (Write method = Write or Safe write). User interface should be uniform for all settings of the component, that's why 'const' is not used.|'Source' parameter of SetBlockFlash method can be declared as const but only in specific component's setting (Write method = Write or Safe write). User interface should be uniform for all settings of the component, that's why 'const' is not used.]
Doc_Misra_Rule_16_Location=[ExtInt|ExtInt]
Doc_Misra_Rule_17_Location=[IO_Map.h|PE_Types.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|FreescaleCAN|IntFLASH|PE_Timer|PPG|PWM|PWMMC|SynchroMaster|SynchroSlave|IO_Map.h|PE_Types.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|FreescaleCAN|IntFLASH|PE_Timer|PPG|PWM|PWMMC|SynchroMaster|SynchroSlave]
Doc_Misra_Rule_18_Location=[Global|Cpu|IO_Map.h|PE_Types.h|LCD|ExtInt|IntFlash|WatchDog|PE_Timer|AsynchroMaster|Global|Cpu|IO_Map.h|PE_Types.h|LCD|ExtInt|IntFlash|WatchDog|PE_Timer|AsynchroMaster]
Doc_Misra_Rule_18_Location_Reason=[Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros = yes' option (Build Options).|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: GetPllLockStatusFlag, GetLowVoltageFlag, SetStopMode, SetWaitMode, DisableInt, EnableInt, GetSpeedMode|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: __RESET_WATCHDOG|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: All macros for register access, __DI, __EI, EnterCritical, ExitCritical, SaveStatusReg, RestoreStatusReg, PE_DEBUGHALT, ISR|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: SetPixel, GetPixel|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Enable, Disable,GetVal|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Busy, EnableEvent, DisableEvent|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Clear|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macros: LngHi5|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: Standby, LoopMode, SetDirection, TurnRxOff, TurnRxOn, TurnTxOff, TurnTxOn, GetTxComplete|Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros = yes' option (Build Options).|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: GetPllLockStatusFlag, GetLowVoltageFlag, SetStopMode, SetWaitMode, DisableInt, EnableInt, GetSpeedMode|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: __RESET_WATCHDOG|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: All macros for register access, __DI, __EI, EnterCritical, ExitCritical, SaveStatusReg, RestoreStatusReg, PE_DEBUGHALT, ISR|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: SetPixel, GetPixel|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Enable, Disable,GetVal|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Busy, EnableEvent, DisableEvent|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Clear|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macros: LngHi5|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: Standby, LoopMode, SetDirection, TurnRxOff, TurnRxOn, TurnTxOff, TurnTxOn, GetTxComplete]
Doc_Misra_Rule_19_Location=[PE_Types.h|PE_Types.h]
Doc_Misra_Rule_1_Location=[Global|PE_Types.h|IO_Map.h|Vectors.c|Cpu|IntFlash|IntEEPROM|SW_I2C|Init_SAW|InternalI2C|AsynchroSerial|BitIO|FreescaleAnalogComp|Init_IRTC|Init_PRACMP|ExtInt|Global|PE_Types.h|IO_Map.h|Vectors.c|Cpu|IntFlash|IntEEPROM|SW_I2C|Init_SAW|InternalI2C|AsynchroSerial|BitIO|FreescaleAnalogComp|Init_IRTC|Init_PRACMP|ExtInt]
Doc_Misra_Rule_1_Location_ExtInt=[|]
Doc_Misra_Rule_1_Location_Reason=[All components may contain one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|All components may contain one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.]
Doc_Misra_Rule_20_Location=[PE_Types.h|PE_Types.h]
Doc_Misra_Rule_20_Location_Reason=[Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.]
Doc_Misra_Rule_21_Location=[Global|Global]
Doc_Misra_Rule_2_Location=[Cpu|ADC|PE_Cnvrt.c|MeasurementEngine|IntFlash|Byte2IO|Byte3IO|Byte4IO|IntEEPROM|Cpu|ADC|PE_Cnvrt.c|MeasurementEngine|IntFlash|Byte2IO|Byte3IO|Byte4IO|IntEEPROM]
Doc_Misra_Rule_2_Location_Lint=[Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]]
Doc_Misra_Rule_2_Location_Reason=[When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to function.|PC-Lint reports for summing of the calibration registers values by Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|PC-Lint reports for operations with status variables (EnChan, EnChanFlags, ChRun). The variables are declared as volatile, but the order of variables access is not important, because the variables are not mutualy dependent.|PC-Lint reports for summing of the calibration registers values by ADC_Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to function.|PC-Lint reports for summing of the calibration registers values by Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|PC-Lint reports for operations with status variables (EnChan, EnChanFlags, ChRun). The variables are declared as volatile, but the order of variables access is not important, because the variables are not mutualy dependent.|PC-Lint reports for summing of the calibration registers values by ADC_Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.]
Doc_Misra_Rule_3_Location=[Global|Global]
Doc_Misra_Rule_4_Location=[IO_Map.h|IO_Map.h]
Doc_Misra_Rule_5_Location=[IO_Map.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|SynchroMaster|SynchroSlave|PWMMC|SPI2UART|IO_Map.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|SynchroMaster|SynchroSlave|PWMMC|SPI2UART]
Doc_Misra_Rule_6_Location=[Cpu|Cpu]
Doc_Misra_Rule_7_Location=[RTC|RTC]
Doc_Misra_Rule_8_Location=[Cpu|IntFlash|Init_SAW|IntEEPROM|Cpu|IntFlash|Init_SAW|IntEEPROM]
Doc_Misra_Rule_8_Location_Reason=[Internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer;<br/> When Interrupt vector table is generated into RAM, pointers to ISR functions are initialized by typecast of an integral value to the function pointer type. Typecast from pointer to integral type is also used in SetIntVect method when checking parameter value;<br/>SetBackdoorKey method uses typecast from pointer to integral to pass parameter to high level inline assembly routine placed in RAM.<br/> In interrupt vector table in Device Initialization, unassigned ISR are initialized by typecast of an integral value to the function pointer type.|Driver writing to FLASH memory uses pointer type for accessing data in the memory and integer type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|SAW internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer.|Driver for D-Flash memory type writing to EEPROM memory uses pointer type for accessing data in the memory and integral type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|Internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer;<br/> When Interrupt vector table is generated into RAM, pointers to ISR functions are initialized by typecast of an integral value to the function pointer type. Typecast from pointer to integral type is also used in SetIntVect method when checking parameter value;<br/>SetBackdoorKey method uses typecast from pointer to integral to pass parameter to high level inline assembly routine placed in RAM.<br/> In interrupt vector table in Device Initialization, unassigned ISR are initialized by typecast of an integral value to the function pointer type.|Driver writing to FLASH memory uses pointer type for accessing data in the memory and integer type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|SAW internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer.|Driver for D-Flash memory type writing to EEPROM memory uses pointer type for accessing data in the memory and integral type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.]
Doc_Misra_Rule_9_Location=[Cpu|Term|IntFlash|ADC|PE_Cnvrt.c|Capture|MeasurementEngine|IntEEPROM|PWMMC|Cpu|Term|IntFlash|ADC|PE_Cnvrt.c|Capture|MeasurementEngine|IntEEPROM|PWMMC]
Doc_Misra_Rule_9_Location_Reason=[When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to a function.|Conversion between pointer to char type and pointer to unsigned char type is used in ReadChar method to receive characters.|When writing to FLASH memory, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>When Virtual page is enabled, it's possible to write or read a byte, a word or a double word to or from Virtual page (GetBytePage, SetBytePage, GetWordPage, SetWordPage, GetLongPage and SetLongPage methods). Pointer cast of the Virtual Page array to the desired type is used in these methods.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|Typecast between pointers is used in GetCaptureValue method in case, it is generated as a macro.|Typecast between pointers is used when an array of pointers is accessed, which contains register addresses.|The EEPROM peripheral module (D-Flash memory type) works with two data bytes (word) for write operation, but access to one byte is needed (GetByte, SetByte methods). Conversion between the pointer to byte and pointer to word is used and typecast for pointer arithmetic is used.|Typecast between pointers is used in SetRatio16 method for ratio calculation.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to a function.|Conversion between pointer to char type and pointer to unsigned char type is used in ReadChar method to receive characters.|When writing to FLASH memory, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>When Virtual page is enabled, it's possible to write or read a byte, a word or a double word to or from Virtual page (GetBytePage, SetBytePage, GetWordPage, SetWordPage, GetLongPage and SetLongPage methods). Pointer cast of the Virtual Page array to the desired type is used in these methods.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|Typecast between pointers is used in GetCaptureValue method in case, it is generated as a macro.|Typecast between pointers is used when an array of pointers is accessed, which contains register addresses.|The EEPROM peripheral module (D-Flash memory type) works with two data bytes (word) for write operation, but access to one byte is needed (GetByte, SetByte methods). Conversion between the pointer to byte and pointer to word is used and typecast for pointer arithmetic is used.|Typecast between pointers is used in SetRatio16 method for ratio calculation.]
PE_MisraErrorCodes=[46]
SerFlagBits=[/* Bit 0 - Overrun error */|/* Bit 1 - Common error of RX */|/* Bit 2 - Char in RX buffer */|/* Bit 3 - Interrupt is in progress */|/* Bit 4 - Full RX buffer */|/* Bit 5 - Full TX buffer */]
revAuth=[JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|JCh|PC|PC|PC|PC|PC|PC|PC|PC|PC|PC|MN|SA|MN|PF|PF|PF|MN]
revCmnt_0=[SaveStatusReg() and RestoreStatusReg() macros have been replaced by EnterCritical() and ExitCritical() macros.|The SetDirection method has been added.]
revCmnt_1=[IRQ pins supported for CTS.|The EnableEvent and the DisableEvent methods are available as macros.|Support for Ignore range checking, Ignore speed test and Ignore speed mode test have been done.]
revCmnt_10=[Support for new derivatives has been added - QG8, QG4, LC60, LC36, GT16A, MC13214]
revCmnt_11=[Declaration of unused variable in Handshake control mode fixed.]
revCmnt_12=[Support for new derivatives has been added - AW16A, AC16A, GB60A, GT60A.|New event OnRxCharExt has been added.|ClearRxBuf method modified - deassertion of RTS signal added, clearing of internal flags added.|SetBreak method - incorrect detection of full buffer fixed.|Improved MISRA compatibility.]
revCmnt_13=[Fix in the InterruptRx - the OnFullRxBuf event wasn't called with the RTS enabled|Duplicate code in HWEnDi and Enable/Disable in configuration with more speed modes removed.]
revCmnt_14=[Fixed initialization of CTS, when user renames the pin.]
revCmnt_15=[Support for new derivatives has been added - DZ60, DV60, DV16, DN60, EN32, DE60.|Method RecvBlock modified - the method now returns all available data (up to requested amount) in the receive buffer even when a reception error is detected. The previous version in this case stopped immediately and returned with incorrect number of data received.|Modification of ISR routines to reduce risk of losing characters when interrups are disabled for too long.]
revCmnt_16=[CTS support fot LC60 fixed.]
revCmnt_17=[Support of new derivative has been added - SH, SG, EL, SL, QE and ColdFireV1.]
revCmnt_18=[Added support for changing pin sets.]
revCmnt_19=[Macro and function EnableEvent has been tuned up.]
revCmnt_2=[Support of new derivate - RG60/32 family.|Fixed bug for renamed KBI pins.]
revCmnt_20=[Type casting corrections for CFV1.]
revCmnt_21=[Support of new derivative has been added AC60, AC128, DZ128, DV128, JM60, QE8, RS08SA12.|Correction of undefined symbol Priority for subrutine setEventPriority.|SendChar method macro code has been optimized.]
revCmnt_22=[Added support for interrupt vector Vportj for CTS pin on DZ,DV128 derivatives.]
revCmnt_23=[Support of new derivative has been added SH32, SG32, MCF51JM128.]
revCmnt_24=[Support of new derivative has been added LL16, QB8, QE32, MCF51AC256 and RS08LA8.]
revCmnt_25=[Support of new derivative has been added JS16, AW16_64, QG8_24, RE16_48, SH8_24, MCF51CN128 and RS08LE4.|MISRA compliance improved]
revCmnt_26=[New derivatives support added: EM256,EM128,LL64,LL36,LH64,LH36]
revCmnt_27=[Support of new derivative has been added SV16/8,FL16/8,MP16/12,LG32/16,AC128(44 pin package).]
revCmnt_28=[Function of the OnRxCharExt event has been corrected.]
revCmnt_29=[Support of new derivative has been added AG128, KB12 and SC4.|Added support of baud rate fine adjust.|OnFreeTxBuf event functionality corrected.|HW overrun processing corrected.|Removed far pointer from SendBlock method parameter (RS08 only).]
revCmnt_3=[Rx pin pull-up-disable initialization added.]
revCmnt_30=[Support of new derivative has been added MCF51MM256/128, MC9S08MM128/64, MCF51JE256/128, MC9S08JE128/64, IA4, IB8/4 and IC8.]
revCmnt_31=[Support of new derivative has been added AC128_48, MM32A.]
revCmnt_32=[MISRA support has been improved]
revCmnt_4=[The testing of flags has been corrected in the RecvChar method.|The SendBlock method has been optimized. The SetBreak, SetIdle methods and interrupt routines have been corrected.|Global exported variables has been marked as volatile.]
revCmnt_5=[Interrupt vector renamed.|Fixed internal error: Cannot redefine symbol "ivINT_Keyboard1" with new value.|SendBlock and RecvBlock methods have been corrected.|Tiny memory model support added.]
revCmnt_6=[The interruptRx routine and the interruptError routine have been corrected.]
revCmnt_7=[Support for new derivatives has been added - AW60, GT_48.|Definition\declaration of interrupts has been modified. SetDirection method has been modified.|Bug in the RecvChar has been fixed.|New event OnTxComplete has been added.|Optimization of buffer access.]
revCmnt_8=[Methods GetCharsInRxBuf and GetCharsInTxBuf are in some configurations available as macros.|Tiny memory model support added into SendBlock method.]
revCmnt_9=[Property StopInWaitHCS08 has been renamed to StopInWait.]
revDate=[30.09.2010|24.03.2010|12.10.2009|04.05.2009|30.03.2009|20.02.2009|6.11.2008|12.08.2008|18.02.2008|21.11.2007|24.07.2007|24.05.2007|11.04.2007|27.03.2007|16.03.2007|06.03.2007|20.11.2006|18.10.2006|10.05.2006|05.04.2006|19.01.2006|18.03.2005|19.07.2005|21.03.2005|27.01.2005|30.08.2004|29.06.2004|20.05.2004|24.11.2003|04.11.2003|13.10.2003|01.10.2003|03.04.2003]
revLvl=[2|5|5|2|2|5|5|5|5|5|5|3|5|5|5|5|5|2|2|2|2|3|3|5|3|3|3|3|5|5|5|5|3]
revVer=[01.33|01.32|01.31|01.30|01.29|01.28|01.27|01.26|01.25|01.24|01.23|01.22|01.21|01.20|01.19|01.18|01.17|01.16|01.15|01.14|01.13|01.12|01.11|01.10|01.09|01.08|01.07|01.06|01.05|01.04|01.03|01.02|01.01]
revVrf=[RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH|RH]

 LOCAL SYMBOLS (alphabet order)
-------------------------------
ActEdgeDetect=Disabled
BaudRate=58254
BeanVersion=02.601
BreakLength=0
CHG_BeanIsEnabled=yes
CPUCond=
CPUCond0=
CPUCond1=
CPUCond3=
CPUCond4=
CPUCond6=
CPUCond7=
CPUCondHCS12X=
CPU_HCS08_HCS12=
CPU_HCS08_HCS13=
CPU_HCS08_HCS14=
CTSsupport=no
CharsInRxBuf=CharsInRxBuf
CharsInRxBuf_Hint=byte Terminal_CharsInRxBuf(word *Chr);
CharsInRxBuf_HintHint=Returns the number of characters in the input buffer. This method is...
CharsInRxBuf_HintHintLong=Returns the number of characters in the input buffer. This method is available only if the receiver property is enabled.  [deprecated method]
ClearRxBuf=ClearRxBuf
ClearRxBuf_Hint=byte Terminal_ClearRxBuf(void);
ClearRxBuf_HintHint=Clears the receive buffer.  This method is available only if non-zero length...
ClearRxBuf_HintHintLong=Clears the receive buffer.  This method is available only if non-zero length of the input buffer is defined and the receiver property is enabled.
ClearTxBuf=ClearTxBuf
ClearTxBuf_Hint=byte Terminal_ClearTxBuf(void);
ClearTxBuf_HintHint=Clears the transmit buffer.  This method is available only if non-zero length...
ClearTxBuf_HintHintLong=Clears the transmit buffer.  This method is available only if non-zero length of the output buffer is defined and the receiver property is enabled.
CpuCondMotorola=
CpuCondNoSLIC=
CpuCondNoSLIC1=
DSPgrp1=
DeviceName=Terminal
DeviceType=AsynchroSerial
Disable=Disable
DisableEvent=DisableEvent
DisableEvent_Hint=byte Terminal_DisableEvent(void);
DisableEvent_HintHint=Disables the events. This method is available if the interrupt service/event...
DisableEvent_HintHintLong=Disables the events. This method is available if the interrupt service/event property is enabled and at least one event is enabled.
Disable_Hint=byte Terminal_Disable(void);
Disable_HintHint=Disables the component - it stops the send and receive functions. No events...
Disable_HintHintLong=Disables the component - it stops the send and receive functions. No events will be generated.
ESCILINGrp=
Enable=Enable
EnableEvent=EnableEvent
EnableEvent_Hint=byte Terminal_EnableEvent(void);
EnableEvent_HintHint=Enables the events. This method is available if the interrupt service/event...
EnableEvent_HintHintLong=Enables the events. This method is available if the interrupt service/event property is enabled and at least one event is enabled.
Enable_Hint=byte Terminal_Enable(void);
Enable_HintHint=Enables the component - it starts the send and receive functions. Events may...
Enable_HintHintLong=Enables the component - it starts the send and receive functions. Events may be generated ("DisableEvent"/"EnableEvent").
ErrInt=Vsci1err
ErrIntEdgeAddr=4294934565
ErrIntEdgeReg=SCI1S2
ErrIntEnblAddr=4294934566
ErrIntEnblReg=SCI1C3
ErrIntName=Vsci1err
ErrIntReqAddr=4294934564
ErrIntReqReg=SCI1S1
ErrIntShared=no
ErrIntSharedByOther=no
ErrIntSpecDefaultPriority=450
ErrIntSpecInterruptVectorAddressAddr=304
ErrIntSpecInterruptVectorAddressReg=IntVVsci1err
ErrIntSpecInterruptVectorNumberAddr=76
ErrIntSpecInterruptVectorNumberReg=IntNum
ErrIntSpecPE_SPEC_FEATURE_INT_PRIORITYReg=PE_SPEC_FEATURE_INT_PRIORITY
ErrInt_NMI=no
ErrInt_Name=Vsci1err
ErrInt_RESET=no
ErrInt_SWint=no
EventModule=Events
FeatCondGrpMethodsNoLDD=
GetCharsInRxBuf=GetCharsInRxBuf
GetCharsInRxBuf_Hint=word Terminal_GetCharsInRxBuf(void);
GetCharsInRxBuf_HintHint=Returns the number of characters in the input buffer. This method is...
GetCharsInRxBuf_HintHintLong=Returns the number of characters in the input buffer. This method is available only if the receiver property is enabled.
GetCharsInTxBuf=GetCharsInTxBuf
GetCharsInTxBuf_Hint=word Terminal_GetCharsInTxBuf(void);
GetCharsInTxBuf_HintHint=Returns the number of characters in the output buffer. This method is...
GetCharsInTxBuf_HintHintLong=Returns the number of characters in the output buffer. This method is available only if the transmitter property is enabled.
GetTxComplete=GetTxComplete
GetTxComplete_Hint=bool Terminal_GetTxComplete(void);
GetTxComplete_HintHint=Returns whether the transmitter is finished transmitting all data, preamble,...
GetTxComplete_HintHintLong=Returns whether the transmitter is finished transmitting all data, preamble, and break characters and is idle. It can be used to determine when it is safe to switch a line driver (e.g. in RS-485 applications). This method is available only if event <OnTxComplete> is disabled.
HC08grp0=
HCS08_HCS12grp=
HCS08_HCS12grp0=
HCS08grp0=
HCS12grp1=
HighSpeed=
IdleMode=0
InitBaudRateName=57600baud
InitEnable=no
InitEnableEvents=no
InitPrescaler_Same=yes
InitPriority=440
Inp=PTB0_KBI1P4_RxD1_ADP4
InpBitMask=1
InpBitNum=0
InpBufferSize=15
InpInt=Vsci1rx
InpIntEdgeAddr=4294934565
InpIntEdgeReg=SCI1S2
InpIntEnblAddr=4294934563
InpIntEnblReg=SCI1C2
InpIntName=Vsci1rx
InpIntReqAddr=4294934564
InpIntReqReg=SCI1S1
InpIntShared=no
InpIntSharedByOther=no
InpIntSpecDefaultPriority=440
InpIntSpecInterruptVectorAddressAddr=308
InpIntSpecInterruptVectorAddressReg=IntVVsci1rx
InpIntSpecInterruptVectorNumberAddr=77
InpIntSpecInterruptVectorNumberReg=IntNum
InpIntSpecPE_SPEC_FEATURE_INT_PRIORITYReg=PE_SPEC_FEATURE_INT_PRIORITY
InpInt_NMI=no
InpInt_Name=Vsci1rx
InpInt_RESET=no
InpInt_SWint=no
InpPinName=PTB0_KBI1P4_RxD1_ADP4
InpPinNumber=34
InpPortAddr=4294934530
InpPortCntrAddr=4294934531
InpPortCntrReg=PTBDD
InpPortName=PTB
InpPortPullAddr=4294940740
InpPortPullReg=PTBPE
InpPortReg=PTBD
InpPortSpecPERIPHERAL_BASE_ADDRESSAddr=4294934530
InpPortSpecPERIPHERAL_BASE_ADDRESSReg=PERIPHERAL_BASE_ADDRESS
InpPortSpecSlewAddr=4294940741
InpPortSpecSlewReg=PTBSE
InpPortSpecStrengthAddr=4294940742
InpPortSpecStrengthReg=PTBDS
InpSharedByOther=no
InpSpecATDEnableAddr=4294934551
InpSpecATDEnableReg=APCTL1
InpSpecClkGate2Addr=4294940687
InpSpecClkGate2Reg=SCGC2
InpSpecDeviceNameReg=KBI1
InpSpecIntCtrlAddr=4294934540
InpSpecIntCtrlReg=KBI1SC
InpSpecIntEnableAddr=4294934541
InpSpecIntEnableReg=KBI1PE
InpSpecIntPolarityAddr=4294934542
InpSpecIntPolarityReg=KBI1ES
InpSpecKBI_CHANAddr=16
InpSpecKBI_CHANReg=KBI_CHAN
InpSpecPE_SPEC_FEATURE_KBI_EDGEReg=PE_SPEC_FEATURE_KBI_EDGE
InpSpecPE_SPEC_FEATURE_KBI_V2Reg=PE_SPEC_FEATURE_KBI_V2
InpSupportsDirInp=yes
InpSupportsDirOut=yes
Inp_Name=PTB0_KBI1P4_RxD1_ADP4
IntErrorPriority=450
IntService=yes
IntTxDPriority=430
MCF_CondGrp0=
MCF_CondGrp2=
ModuleName=Terminal
OnFreeTxBuf=Terminal_OnFreeTxBuf
OnFreeTxBufModule=Events
OnFreeTxBufPrior=4
OnFreeTxBuf_Hint=void Terminal_OnFreeTxBuf(void);
OnRxChar=Terminal_OnRxChar
OnRxCharModule=Events
OnRxCharPrior=4
OnRxChar_Hint=void Terminal_OnRxChar(void);
Out=PTB1_KBI1P5_TxD1_ADP5
OutBitMask=2
OutBitNum=1
OutBufferSize=15
OutInt=Vsci1tx
OutIntEdgeAddr=4294934565
OutIntEdgeReg=SCI1S2
OutIntEnblAddr=4294934563
OutIntEnblReg=SCI1C2
OutIntName=Vsci1tx
OutIntReqAddr=4294934564
OutIntReqReg=SCI1S1
OutIntShared=no
OutIntSharedByOther=no
OutIntSpecDefaultPriority=430
OutIntSpecInterruptVectorAddressAddr=312
OutIntSpecInterruptVectorAddressReg=IntVVsci1tx
OutIntSpecInterruptVectorNumberAddr=78
OutIntSpecInterruptVectorNumberReg=IntNum
OutIntSpecPE_SPEC_FEATURE_INT_PRIORITYReg=PE_SPEC_FEATURE_INT_PRIORITY
OutInt_NMI=no
OutInt_Name=Vsci1tx
OutInt_RESET=no
OutInt_SWint=no
OutPinName=PTB1_KBI1P5_TxD1_ADP5
OutPinNumber=33
OutPortAddr=4294934530
OutPortCntrAddr=4294934531
OutPortCntrReg=PTBDD
OutPortName=PTB
OutPortPullAddr=4294940740
OutPortPullReg=PTBPE
OutPortReg=PTBD
OutPortSpecPERIPHERAL_BASE_ADDRESSAddr=4294934530
OutPortSpecPERIPHERAL_BASE_ADDRESSReg=PERIPHERAL_BASE_ADDRESS
OutPortSpecSlewAddr=4294940741
OutPortSpecSlewReg=PTBSE
OutPortSpecStrengthAddr=4294940742
OutPortSpecStrengthReg=PTBDS
OutSharedByOther=no
OutSpecATDEnableAddr=4294934551
OutSpecATDEnableReg=APCTL1
OutSpecClkGate2Addr=4294940687
OutSpecClkGate2Reg=SCGC2
OutSpecDeviceNameReg=KBI1
OutSpecIntCtrlAddr=4294934540
OutSpecIntCtrlReg=KBI1SC
OutSpecIntEnableAddr=4294934541
OutSpecIntEnableReg=KBI1PE
OutSpecIntPolarityAddr=4294934542
OutSpecIntPolarityReg=KBI1ES
OutSpecKBI_CHANAddr=32
OutSpecKBI_CHANReg=KBI_CHAN
OutSpecPE_SPEC_FEATURE_KBI_EDGEReg=PE_SPEC_FEATURE_KBI_EDGE
OutSpecPE_SPEC_FEATURE_KBI_V2Reg=PE_SPEC_FEATURE_KBI_V2
OutSupportsDirInp=yes
OutSupportsDirOut=yes
Out_Name=PTB1_KBI1P5_TxD1_ADP5
RTSsupport=no
Receiver=
RecvBlock=RecvBlock
RecvBlock_Hint=byte Terminal_RecvBlock(Terminal_TComData *Ptr, word Size, word *Rcv);
RecvBlock_HintHint=If any data is received, this method returns the block of the data and its...
RecvBlock_HintHintLong=If any data is received, this method returns the block of the data and its length (and incidental error), otherwise it returns an error code (it does not wait for data).  This method is available only if non-zero length of the input buffer is defined and the receiver property is enabled.  If less than requested number of characters is received only the available data is copied from the receive buffer to the user specified destination. The value ERR_EXEMPTY is returned and the value of variable pointed by the Rcv parameter is set to the number of received characters.
RecvChar=RecvChar
RecvChar_Hint=byte Terminal_RecvChar(Terminal_TComData *Chr);
RecvChar_HintHint=If any data is received, this method returns one character, otherwise it...
RecvChar_HintHintLong=If any data is received, this method returns one character, otherwise it returns an error code (it does not wait for data). This method is enabled only if the receiver property is enabled.  [Note:] Because the preferred method to handle error and break exception in the interrupt mode is to use events <OnError> and <OnBreak> the return value ERR_RXEMPTY has higher priority than other error codes. As a consequence the information about an exception in interrupt mode is returned only if there is a valid character ready to be read.
RuntimeSetting=none
RxDpinSignal=
RxPolarity=Not inverted
SCIOutMode=0
SendBlock=SendBlock
SendBlock_Hint=byte Terminal_SendBlock(Terminal_TComData *Ptr, word Size, word *Snd);
SendBlock_HintHint=Sends a block of characters to the channel.  This method is available only if...
SendBlock_HintHintLong=Sends a block of characters to the channel.  This method is available only if non-zero length of the output buffer is defined and the transmitter property is enabled.
SendChar=SendChar
SendChar_Hint=byte Terminal_SendChar(Terminal_TComData Chr);
SendChar_HintHint=Sends one character to the channel. If the component is temporarily disabled...
SendChar_HintHintLong=Sends one character to the channel. If the component is temporarily disabled (Disable method) SendChar method only stores data into an output buffer. In case of a zero output buffer size, only one character can be stored. Enabling the component (Enable method) starts the transmission of the stored data. This method is available only if the transmitter property is enabled.
Ser=SCI1
SerBaudAddr=4294934560
SerBaudReg=SCI1BD
SerBreak=Disabled
SerBufferInAddr=4294934567
SerBufferInReg=SCI1D
SerBufferOutAddr=4294934567
SerBufferOutReg=SCI1D
SerChanel=SCI1
SerChannel=SCI1
SerControlAddr=4294934562
SerControlReg=SCI1C1
SerFracAddr=4294934566
SerFracReg=SCI1C3
SerModeAddr=4294934563
SerModeReg=SCI1C2
SerParity=none
SerSharedByOther=no
SerSpecAddr=4294934564
SerSpecClkGateAddr=4294940686
SerSpecClkGateReg=SCGC1
SerSpecPERIPHERAL_BASE_ADDRESSAddr=4294934560
SerSpecPERIPHERAL_BASE_ADDRESSReg=PERIPHERAL_BASE_ADDRESS
SerSpecReg=SCI1S1
SerSpecSCIStatusRegister2Addr=4294934565
SerSpecSCIStatusRegister2Reg=SCI1S2
SerStopBit=1
SerWidth=8
Ser_IntRxEnblAddr=4294934563
Ser_IntRxEnblReg=SCI1C2
Ser_IntRxReqAddr=4294934564
Ser_IntRxReqReg=SCI1S1
Ser_IntSpcEnblAddr=4294934566
Ser_IntSpcEnblReg=SCI1C3
Ser_IntSpcReqAddr=4294934564
Ser_IntSpcReqReg=SCI1S1
Ser_IntTxEnblAddr=4294934563
Ser_IntTxEnblReg=SCI1C2
Ser_IntTxReqAddr=4294934564
Ser_IntTxReqReg=SCI1S1
Ser_Name=SCI1
StopInWait=no
Symbol=
Symbol1=
Transmitter=
TxDpinSignal=
TxPolarity=Not inverted
WakeupCond=Idle line wakeup
runHighSpeed=yes
runLowSpeed=no
runSlowSpeed=no
runSpeedModeNum=1
BaudRateE_real=[0.000017166138|undef|undef]
BaudRateE_real_us=[17.166137695312|undef|undef]
BaudRateE_ticks=[1|undef|undef]
BaudRateE_ticksR=[0.5625|undef|undef]
EventList=[Terminal_OnRxChar|Terminal_OnFreeTxBuf]
EventModules=[Events]
InitPrescaler=[27|undef|undef]
MethodHintList=[byte Terminal_Enable(void);|byte Terminal_Disable(void);|byte Terminal_EnableEvent(void);|byte Terminal_DisableEvent(void);|byte Terminal_RecvChar(Terminal_TComData *Chr);|byte Terminal_SendChar(Terminal_TComData Chr);|byte Terminal_RecvBlock(Terminal_TComData *Ptr, word Size, word *Rcv);|byte Terminal_SendBlock(Terminal_TComData *Ptr, word Size, word *Snd);|byte Terminal_ClearRxBuf(void);|byte Terminal_ClearTxBuf(void);|byte Terminal_CharsInRxBuf(word *Chr);|word Terminal_GetCharsInRxBuf(void);|word Terminal_GetCharsInTxBuf(void);|bool Terminal_GetTxComplete(void);]
MethodList=[Enable|Disable|EnableEvent|DisableEvent|RecvChar|SendChar|RecvBlock|SendBlock|ClearRxBuf|ClearTxBuf|CharsInRxBuf|GetCharsInRxBuf|GetCharsInTxBuf|GetTxComplete]
TotalPrescaler=[1|undef|undef]
TotalPrescalerReal=[1|undef|undef]
runSpeedMode=[Yes|No|No]

 DEPRECATED LOCAL SYMBOLS (alphabet order)
------------------------------------------
ErrIntSpec0Reg=PE_SPEC_FEATURE_INT_PRIORITY
ErrIntSpec3Addr=304
ErrIntSpec3Reg=IntVVsci1err
ErrIntSpec4Addr=76
ErrIntSpec4Reg=IntNum
InpIntSpec0Reg=PE_SPEC_FEATURE_INT_PRIORITY
InpIntSpec2Addr=308
InpIntSpec2Reg=IntVVsci1rx
InpIntSpec3Addr=77
InpIntSpec3Reg=IntNum
InpPortSpec0Addr=4294934530
InpPortSpec0Reg=PERIPHERAL_BASE_ADDRESS
InpPortSpec1Addr=4294940741
InpPortSpec1Reg=PTBSE
InpPortSpec2Addr=4294940742
InpPortSpec2Reg=PTBDS
InpSpec0Addr=4294934551
InpSpec0Reg=APCTL1
InpSpec1Addr=4294934540
InpSpec1Reg=KBI1SC
InpSpec2Addr=4294934541
InpSpec2Reg=KBI1PE
InpSpec3Addr=4294934542
InpSpec3Reg=KBI1ES
InpSpec4Addr=4294940687
InpSpec4Reg=SCGC2
InpSpec5Addr=16
InpSpec5Reg=KBI_CHAN
InpSpec6Reg=PE_SPEC_FEATURE_KBI_EDGE
InpSpec7Reg=PE_SPEC_FEATURE_KBI_V2
InpSpec9Reg=KBI1
OutIntSpec0Reg=PE_SPEC_FEATURE_INT_PRIORITY
OutIntSpec2Addr=312
OutIntSpec2Reg=IntVVsci1tx
OutIntSpec3Addr=78
OutIntSpec3Reg=IntNum
OutPortSpec0Addr=4294934530
OutPortSpec0Reg=PERIPHERAL_BASE_ADDRESS
OutPortSpec1Addr=4294940741
OutPortSpec1Reg=PTBSE
OutPortSpec2Addr=4294940742
OutPortSpec2Reg=PTBDS
OutSpec0Addr=4294934551
OutSpec0Reg=APCTL1
OutSpec1Addr=4294934540
OutSpec1Reg=KBI1SC
OutSpec2Addr=4294934541
OutSpec2Reg=KBI1PE
OutSpec3Addr=4294934542
OutSpec3Reg=KBI1ES
OutSpec4Addr=4294940687
OutSpec4Reg=SCGC2
OutSpec5Addr=32
OutSpec5Reg=KBI_CHAN
OutSpec6Reg=PE_SPEC_FEATURE_KBI_EDGE
OutSpec7Reg=PE_SPEC_FEATURE_KBI_V2
OutSpec9Reg=KBI1
SerSpec0Addr=4294934565
SerSpec0Reg=SCI1S2
SerSpec1Addr=4294940686
SerSpec1Reg=SCGC1
SerSpec2Addr=4294934560
SerSpec2Reg=PERIPHERAL_BASE_ADDRESS
runSleep=no


GLOBAL SYMBOLS (alphabet order)
-------------------------------
ADCAsynchroClockAddr=4294934550
ADCAsynchroClockReg=ADCCFG
ADCBusClockAddr=4294934550
ADCBusClockReg=ADCCFG
ADCClkSelAddr=4294934550
ADCClkSelReg=ADCCFG
ADCConstPrescAddr=4294934550
ADCConstPrescReg=ADCCFG
ActiveConfigIdentifier=PEcfg_Release_51QE128CLH
ActiveConfiguration=Release_51QE128CLH
BDIVAddr=4294934585
BDIVReg=ICSC2
COPBusClkPrescAddr=4294940674
COPBusClkPrescReg=SOPT1
COPClkSelAddr=4294940675
COPClkSelReg=SOPT2
COPIntClkPrescAddr=4294940674
COPIntClkPrescReg=SOPT1
CPUDB_CW_MCU_ID=28672
CPUDB_CW_MCU_NAME=MCF51QE128
CPUDB_Flash_EraseSectorSize=1024
CPUDB_Flash_NumOfBlocks=1
CPUDB_LQFP64=-1
CPUDB_MCF51QE128=-1
CPUDB_PACKAGE=LQFP64
CPU_DB_version=3.00.080
CPUendian=big
CPUfamily=ColdFireV1
CPUproducer=Freescale
CPUrunSpeedModeNum=1
CPUsubFamily=MCF51QE
CPUtype=MCF51QE128_64
CPUvariant=MCF51QE128CLH
C_FAR_MOD=
C_GenMacros=yes
ClientDir_Binary=F:\Proyectos\Robot-QE128\Sources\
ClientDir_Code=F:\Proyectos\Robot-QE128\Generated_Code\
ClientDir_PE=C:\Freescale\CW MCU v10.3\MCU\ProcessorExpert\
ClientDir_Project=F:\Proyectos\Robot-QE128\
CommentBrackets=/**/
Compiler=CodeWarriorColdFireV1
CompilerID=CodeWarrior ColdFireV1 C Compiler
DirRel_Binary=Sources\
DirRel_BinaryToEvents=
DirRel_Code=Generated_Code\
DirRel_Docs=Documentation\
DirRel_EventToBinary=
DirRel_Events=Sources\
DirRel_ProjectSettings=Project_Settings\
EclipseProjectName=Robot-QE128
FLLClkSelAddr=4294934587
FLLClkSelReg=ICSSC
FLL_32kHzAddr=4294934587
FLL_32kHzReg=ICSSC
FLL_DefaultAddr=4294934587
FLL_DefaultReg=ICSSC
HighClock_kHz=33
HighClock_kHz_real=32.768
HighSpeedClock=Internal Clock
High_TPM3=
IO_Map_WatchDogResetMethod=WriteAny
IO_Map_WatchDogServiceRegister=SRS
InterruptTableType=ROM
Language=ANSIC
Not_for_MPC512x=
Not_for_MPC5500_MCF=
O_PIB_full_Init=no
OnChipEEPROM=0
OnChipFLASH=131072
OnChipRAM=8192
PE_DEVELOPMENT=
PE_ECLIPSE=
PE_GENERATING=
PE_G_CRI_CPUENABLE_set0_TPM3SC=16
PE_G_CRI_CPUENABLE_set1_TPM3SC=8
PE_G_CRI_CPUINIT_set0_PTBD=0
PE_G_CRI_CPUINIT_set0_PTBDD=1
PE_G_CRI_CPUINIT_set0_PTCD=10
PE_G_CRI_CPUINIT_set0_PTCDD=0
PE_G_CRI_CPUINIT_set0_PTCPE=0
PE_G_CRI_CPUINIT_set1_PTBD=2
PE_G_CRI_CPUINIT_set1_PTBDD=2
PE_G_CRI_CPUINIT_set1_PTCD=5
PE_G_CRI_CPUINIT_set1_PTCDD=15
PE_G_CRI_CPUINIT_set1_PTCPE=10
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_set0_TPM3SC=0
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_set1_TPM3SC=8
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set0_TPM3CNTH=255
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set0_TPM3SC=255
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set1_TPM3CNTH=0
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set1_TPM3SC=0
PE_G_MisraCnfBackParams_0=
PE_G_MisraCnfBackParams_1=
PE_G_MisraCnfParams_0=
PE_G_MisraCnfParams_1=
PE_G_MisraRuleList_0=
PE_G_MisraRuleList_1=
PE_G_MisraStackIdx=-1
PE_ProductVersion=10.0
PEversion=05.03
PEversionDecimal=1283
ProcessorModule=Cpu
ProcessorName=Cpu
ProjectModule=ProcessorExpert
ProjectName=ProcessorExpert
RDIVAddr=4294934584
RDIVReg=ICSC1
RTCExtClkAddr=4294940720
RTCExtClkReg=RTCSC
RTCIntClkAddr=4294940720
RTCIntClkReg=RTCSC
RTCIntOscAddr=4294940720
RTCIntOscReg=RTCSC
ServerDir_PE=C:\Freescale\CW MCU v10.3\MCU\ProcessorExpert\
SetHighSpeedMode=Internal Clock
SupportedCPUfamily=
TimeStamp=2013-04-23, 06:54, # CodeGen: 67
VirtualTPM1PrescAddr=4294934592
VirtualTPM1PrescReg=TPM1SC
VirtualTPM2PrescAddr=4294934608
VirtualTPM2PrescReg=TPM2SC
VirtualTPM3PrescAddr=4294934624
VirtualTPM3PrescReg=TPM3SC
Xtal_kHz=0
Xtal_kHz_real=0
ivVsci1err=Terminal_InterruptError
ivVsci1rx=Terminal_InterruptRx
ivVsci1tx=Terminal_InterruptTx
ivVtpm1ch0=OSTimerTickISR
ivVtrap14=OSSyscallISR

 DEPRECATED GLOBAL SYMBOLS (alphabet order)
-------------------------------------------
ADCAsynchroClockAddr=null
ADCAsynchroClockReg=null
ADCBusClockAddr=null
ADCBusClockReg=null
ADCClkSelAddr=null
ADCClkSelReg=null
ADCConstPrescAddr=null
ADCConstPrescReg=null
ActiveConfigIdentifier=null
ActiveConfiguration=null
BDIVAddr=null
BDIVReg=null
COPBusClkPrescAddr=null
COPBusClkPrescReg=null
COPClkSelAddr=null
COPClkSelReg=null
COPIntClkPrescAddr=null
COPIntClkPrescReg=null
CPUDB_CW_MCU_ID=null
CPUDB_CW_MCU_NAME=null
CPUDB_Flash_EraseSectorSize=null
CPUDB_Flash_NumOfBlocks=null
CPUDB_LQFP64=null
CPUDB_MCF51QE128=null
CPUDB_PACKAGE=null
CPU_DB_version=null
CPUendian=null
CPUfamily=null
CPUproducer=null
CPUrunSpeedModeNum=null
CPUsubFamily=null
CPUtype=null
CPUvariant=null
C_FAR_MOD=null
C_GenMacros=null
ClientDir_Binary=null
ClientDir_Code=null
ClientDir_PE=null
ClientDir_Project=null
CommentBrackets=null
Compiler=null
CompilerID=null
DirRel_Binary=null
DirRel_BinaryToEvents=null
DirRel_Code=null
DirRel_Docs=null
DirRel_EventToBinary=null
DirRel_Events=null
DirRel_ProjectSettings=null
EclipseProjectName=null
FLLClkSelAddr=null
FLLClkSelReg=null
FLL_32kHzAddr=null
FLL_32kHzReg=null
FLL_DefaultAddr=null
FLL_DefaultReg=null
HighClock_kHz=null
HighClock_kHz_real=null
HighSpeedClock=null
High_TPM3=null
IO_Map_WatchDogResetMethod=null
IO_Map_WatchDogServiceRegister=null
InterruptTableType=null
Language=null
Not_for_MPC512x=null
Not_for_MPC5500_MCF=null
O_PIB_full_Init=null
OnChipEEPROM=null
OnChipFLASH=null
OnChipRAM=null
PE_DEVELOPMENT=null
PE_ECLIPSE=null
PE_GENERATING=null
PE_G_CRI_CPUENABLE_set0_TPM3SC=null
PE_G_CRI_CPUENABLE_set1_TPM3SC=null
PE_G_CRI_CPUINIT_set0_PTBD=null
PE_G_CRI_CPUINIT_set0_PTBDD=null
PE_G_CRI_CPUINIT_set0_PTCD=null
PE_G_CRI_CPUINIT_set0_PTCDD=null
PE_G_CRI_CPUINIT_set0_PTCPE=null
PE_G_CRI_CPUINIT_set1_PTBD=null
PE_G_CRI_CPUINIT_set1_PTBDD=null
PE_G_CRI_CPUINIT_set1_PTCD=null
PE_G_CRI_CPUINIT_set1_PTCDD=null
PE_G_CRI_CPUINIT_set1_PTCPE=null
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_set0_TPM3SC=null
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_set1_TPM3SC=null
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set0_TPM3CNTH=null
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set0_TPM3SC=null
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set1_TPM3CNTH=null
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set1_TPM3SC=null
PE_G_MisraCnfBackParams_0=null
PE_G_MisraCnfBackParams_1=null
PE_G_MisraCnfParams_0=null
PE_G_MisraCnfParams_1=null
PE_G_MisraRuleList_0=null
PE_G_MisraRuleList_1=null
PE_G_MisraStackIdx=null
PE_ProductVersion=null
PEversion=null
PEversionDecimal=null
ProcessorModule=null
ProcessorName=null
ProjectModule=null
ProjectName=null
RDIVAddr=null
RDIVReg=null
RTCExtClkAddr=null
RTCExtClkReg=null
RTCIntClkAddr=null
RTCIntClkReg=null
RTCIntOscAddr=null
RTCIntOscReg=null
ServerDir_PE=null
SetHighSpeedMode=null
SupportedCPUfamily=null
TimeStamp=null
VirtualTPM1PrescAddr=null
VirtualTPM1PrescReg=null
VirtualTPM2PrescAddr=null
VirtualTPM2PrescReg=null
VirtualTPM3PrescAddr=null
VirtualTPM3PrescReg=null
Xtal_kHz=null
Xtal_kHz_real=null
ivVsci1err=null
ivVsci1rx=null
ivVsci1tx=null
ivVtpm1ch0=null
ivVtrap14=null

 GLOBAL LISTS (alphabet order)
-------------------------------------------
ADCAsynchroClock=[1|undef|undef]
ADCAsynchroClock_Setting=[1|undef|undef]
ADCBusClock=[1|undef|undef]
ADCBusClock_Setting=[1|undef|undef]
ADCClkSel=[1|undef|undef]
ADCClkSel_Setting=[ADCBusClock|undef|undef]
ADCConstPresc=[20|undef|undef]
ADCConstPresc_Setting=[20|undef|undef]
BDIV=[1|undef|undef]
BDIV_Setting=[1|undef|undef]
CLKClkSel=[1|undef|undef]
CLKClkSel_Setting=[FLLClkSel|undef|undef]
COPBusClkPresc=[8192|undef|undef]
COPBusClkPresc_Setting=[8192|undef|undef]
COPClkSel=[1|undef|undef]
COPClkSel_Setting=[COPIntClkPresc|undef|undef]
COPIntClkPresc=[32|undef|undef]
COPIntClkPresc_Setting=[32|undef|undef]
CPUsystem_ticks=[0|undef|undef]
EventModuleList=[Events]
FLLClkSel=[1|undef|undef]
FLLClkSel_Setting=[FLL_Default|undef|undef]
FLL_32kHz=[608|undef|undef]
FLL_32kHz_Setting=[608|undef|undef]
FLL_Default=[1536|undef|undef]
FLL_Default_Setting=[1536|undef|undef]
IREFSClkSel=[1|undef|undef]
IREFSClkSel_Setting=[IREFSIntClk|undef|undef]
IncludeSharedModules=[PE_Types|PE_Error|PE_Const|IO_Map|PE_Timer]
InstructionClock=[25.165824|undef|undef]
ModuleList=[IV1|IV2|MotorD1|MotorD2|MotorI1|MotorI2|Terminal|Encoders]
PE_G_CRI_CPUENABLE_RegList8=[TPM3SC]
PE_G_CRI_CPUINIT_RegList8=[PTCDD|PTCD|PTCPE|PTBDD|PTBD]
PE_G_CRI_CPUINIT_prev_PTBDD=[ PTBD]
PE_G_CRI_CPUINIT_prev_PTCDD=[PTCD|PTCD]
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_RegList8=[TPM3SC]
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_RegList8=[TPM3SC|TPM3CNTH]
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_prev_TPM3CNTH=[TPM3SC|TPM3SC]
PE_Timer=[LngMul|LngHi3|LngHi2]
ProjectSharedModulesC=[IO_Map|PE_Timer]
RDIV=[undef|undef|undef]
RDIV_Setting=[undef|undef|undef]
RTCClkSel=[1|undef|undef]
RTCClkSel_Setting=[RTCIntClk|undef|undef]
RTCExtClk=[undef|undef|undef]
RTCExtClk_Setting=[undef|undef|undef]
RTCIntClk=[1|undef|undef]
RTCIntClk_Setting=[1|undef|undef]
RTCIntOsc=[1|undef|undef]
RTCIntOsc_Setting=[1|undef|undef]
SharedModules=[ColdFireV1\PE_Types.drv|ColdFireV1\PE_Error.drv|ColdFireV1\PE_Const.drv|ColdFireV1\IO_Map.drv|HCS08\PE_Timer.drv]
SpeedModeInitAfterNames=[AFTER_HIGH|AFTER_LOW|AFTER_SLOW]
SpeedModeInitBeforeNames=[BEFORE_HIGH|BEFORE_LOW|BEFORE_SLOW]
SpeedModeNames=[High|Low|Slow]
SystemPrescaler=[1|undef|undef]
SystemPrescaler_Setting=[1|undef|undef]
TPM1ClkSel=[1|undef|undef]
TPM1ClkSel_Setting=[TPM1BusClk|undef|undef]
TPM2ClkSel=[1|undef|undef]
TPM2ClkSel_Setting=[TPM2BusClk|undef|undef]
TPM3ClkSel=[1|undef|undef]
TPM3ClkSel_Setting=[TPM3BusClk|undef|undef]
VirtualTPM1Presc=[1|undef|undef]
VirtualTPM1Presc_Setting=[1|undef|undef]
VirtualTPM2Presc=[1|undef|undef]
VirtualTPM2Presc_Setting=[1|undef|undef]
VirtualTPM3Presc=[1|undef|undef]
VirtualTPM3Presc_Setting=[1|undef|undef]

{{DEVELOPMENT}} --------(((DEBUGINFO)))--------.{{DEVELOPMENT}} 

