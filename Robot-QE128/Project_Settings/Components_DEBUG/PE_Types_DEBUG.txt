Debug info from  (Device - PE_Types)  (Module - PE_Types)


{{DEVELOPMENT}} --------(((DEBUGINFO)))--------{{DEVELOPMENT}} 

 DRIVER SYMBOLS (alphabet order)
-------------------------------
Abstract=Common\PE_TypesAbstract.inc
Doc_Misra_Rule_1=1.1
Doc_Misra_Rule_10=12.4
Doc_Misra_Rule_10_Description=The right-hand operand of a logical && or || operator shall not contain side effects.
Doc_Misra_Rule_10_Lint=Note 960: Violates MISRA 2004 Required Rule 12.4, side effects on right hand of logical operator
Doc_Misra_Rule_10_Reason=See detailed description for particular component
Doc_Misra_Rule_10_Type=Required
Doc_Misra_Rule_11=12.10
Doc_Misra_Rule_11_Description=The comma operator shall not be used.
Doc_Misra_Rule_11_Lint=Note 960: Violates MISRA 2004 Required Rule 12.10, comma operator used
Doc_Misra_Rule_11_Reason=Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled only for 'Generate macros = yes'  option (Build Options)
Doc_Misra_Rule_11_Type=Required
Doc_Misra_Rule_12=14.2
Doc_Misra_Rule_12_Description=All non-null statements shall either: <br/>a) have at least one side effect however executed, <br/>or b) cause control flow to change.
Doc_Misra_Rule_12_Lint=Warning 522: Highest operation, function 'string', lacks side-effects [MISRA 2004 Rule 14.2]
Doc_Misra_Rule_12_Reason=PC-lint reports the warning for functions, which are wrappers for inline asm block (asm block is ignored by PC-lint).
Doc_Misra_Rule_12_Type=Required
Doc_Misra_Rule_13=14.3
Doc_Misra_Rule_13_Description=A null statement shall only occur on a line by itself
Doc_Misra_Rule_13_Lint=Note 960: Violates MISRA 2004 Required Rule 14.3, null statement not in line by itself
Doc_Misra_Rule_13_Reason=Several inline asm instructions are in one line separated by semicolon (asm() is ignored by PC-lint).
Doc_Misra_Rule_13_Type=Required
Doc_Misra_Rule_14=14.7
Doc_Misra_Rule_14_Description=A function shall have a single point of exit at the end of the function.
Doc_Misra_Rule_14_Lint=Note 904: Return statement before end of function [MISRA 2004 Rule 14.7]
Doc_Misra_Rule_14_Reason=Use of multiple return statements simplifies the code logic.
Doc_Misra_Rule_14_Type=Required
Doc_Misra_Rule_15=16.7
Doc_Misra_Rule_15_Description=A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object.
Doc_Misra_Rule_15_Lint=Info 818: Pointer parameter could be declared as pointing to const [MISRA 2004 Rule 16.7]
Doc_Misra_Rule_15_Reason=See reasons specified for each component
Doc_Misra_Rule_15_Type=Advisory
Doc_Misra_Rule_16=16.8
Doc_Misra_Rule_16_Description=All exit paths from a function with non-void return type shall have an explicit return statement with an expression.
Doc_Misra_Rule_16_Lint=Warning 533: function should return a value [MISRA 2004 Rule 16.8]
Doc_Misra_Rule_16_Reason=Function contains inline assembler instructions to get value of pin not associated with any port.
Doc_Misra_Rule_16_Type=Required
Doc_Misra_Rule_17=18.4
Doc_Misra_Rule_17_Description=Unions shall not be used.
Doc_Misra_Rule_17_Lint=Note 960: Violates MISRA 2004 Required Rule 18.4, unions shall not be used
Doc_Misra_Rule_17_Reason=Unions are used to efficiently swap bytes in a word or long word, to allow simple access to bit-field and to allow access to bits of registers for peripheral modules.
Doc_Misra_Rule_17_Type=Required
Doc_Misra_Rule_18=19.7
Doc_Misra_Rule_18_Description=A function should be used in preference to a function-like macro.
Doc_Misra_Rule_18_Lint=Note 961: Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined
Doc_Misra_Rule_18_Reason=Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros' = yes option (Build Options).
Doc_Misra_Rule_18_Type=Advisory
Doc_Misra_Rule_19=19.12
Doc_Misra_Rule_19_Description=There shall be at most one occurrence of the # or ## preprocessor operators in a single macro definition.
Doc_Misra_Rule_19_Lint=Note 960: Violates MISRA 2004 Required Rule 19.12, Multiple use of '#/##' operators in macro definition
Doc_Misra_Rule_19_Reason=Multiple occurrences of preprocessor operators are used to convert bit name to bit mask in macros for accessing peripheral registers.
Doc_Misra_Rule_19_Type=Required
Doc_Misra_Rule_1_Description=All code shall conform to ISO 9899-1990 (C-code guideline)
Doc_Misra_Rule_1_Lint=Note 950: Non-ANSI reserved word or construct [MISRA 2004 Rules 1.1 and 2.2]
Doc_Misra_Rule_1_Reason=Non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt, CONVERT_TO_PAGED (RS08 only).
Doc_Misra_Rule_1_Type=Required
Doc_Misra_Rule_2=1.2
Doc_Misra_Rule_20=19.13
Doc_Misra_Rule_20_Description=The # and ## preprocessor operators should not be used.
Doc_Misra_Rule_20_Lint=Note 961: Violates MISRA 2004 Advisory Rule 19.13, '#/##' operator used
Doc_Misra_Rule_20_Reason=Preprocessor operators are used to convert bit name to bit mask in macros for accessing peripheral registers.
Doc_Misra_Rule_20_Type=Advisory
Doc_Misra_Rule_21=19.15
Doc_Misra_Rule_21_Description=Precautions shall be taken in order to prevent the contents of a header file being included twice.
Doc_Misra_Rule_21_Lint=Warning 537: Repeated include file 'PE_Types.h' [MISRA 2004 Rule 19.15]
Doc_Misra_Rule_21_Reason=All generated header files contain associated macro, which definition is tested. The headers file's content is included only if the macro is not defined.
Doc_Misra_Rule_21_Type=Required
Doc_Misra_Rule_2_Description=No reliance shall be placed on undefined or unspecified behavior
Doc_Misra_Rule_2_Lint=See lint message for specific component.
Doc_Misra_Rule_2_Reason=See specific reasons for each component.
Doc_Misra_Rule_2_Type=Required
Doc_Misra_Rule_3=2.4
Doc_Misra_Rule_3_Description=Sections of code should not be 'commented out'.
Doc_Misra_Rule_3_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_3_Reason=Each init component contains 'Commented out' example of interrupt service routine (ISR), if generation of the ISR is enabled.
Doc_Misra_Rule_3_Type=Advisory
Doc_Misra_Rule_4=5.1
Doc_Misra_Rule_4_Description=Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
Doc_Misra_Rule_4_Lint=Warning 621: Identifier clash [MISRA 2004 Rules 1.2, 1.4 and 5.1]
Doc_Misra_Rule_4_Reason=Length of register identifiers of peripheral modules are sometimes longer than 31 characters to comply with the Reference Manual.
Doc_Misra_Rule_4_Type=Required
Doc_Misra_Rule_5=6.4
Doc_Misra_Rule_5_Description=Bit-field shall only be defined to be of type unsigned int or signed int.
Doc_Misra_Rule_5_Lint=Error 46: field type should be int, unsigned int or signed int [MISRA 2004 Rule 6.4]
Doc_Misra_Rule_5_Reason=Unsigned char type is used in bit-fields as smallest possible type.
Doc_Misra_Rule_5_Type=Required
Doc_Misra_Rule_6=8.10
Doc_Misra_Rule_6_Description=All declarations and definitions of objects or function at file scope shall have internal linkage unless external linkage is required.
Doc_Misra_Rule_6_Lint=Info 765: external 'function' could be made static [MISRA 2004 Rule 8.10]
Doc_Misra_Rule_6_Reason=Device Initialization - ISR declaration is subject of various modifications by the user and may or may not be copied to another module - static is not used.
Doc_Misra_Rule_6_Type=Required
Doc_Misra_Rule_7=10.3
Doc_Misra_Rule_7_Description=The value of a complex expression of integer type may only be cast to a type that is narrower and of the same signedness as the underlying type of the expression.
Doc_Misra_Rule_7_Lint=Note 960: Violates MISRA 2004 Required Rule 10.3, Cast of complex expression changes signedness
Doc_Misra_Rule_7_Reason=For IRTC peripheral module, the value of a year in the register is represented by a signed value, but the interface of the component uses unsigned value. Typecast of na expression to unsigned value is used due to less code size.
Doc_Misra_Rule_7_Type=Required
Doc_Misra_Rule_8=11.3
Doc_Misra_Rule_8_Description=A cast should not be performed between a pointer type and an integral type.
Doc_Misra_Rule_8_Lint=Note 923: cast from 'integer type' to pointer [Encompasses MISRA 2004 Rules 11.1 and 11.3], [MISRA 2004 Rule 11.3]
Doc_Misra_Rule_8_Reason=See detailed description for particular component
Doc_Misra_Rule_8_Type=Advisory
Doc_Misra_Rule_9=11.4
Doc_Misra_Rule_9_Description=A cast should be not be performed between a pointer to object type and different pointer to object type
Doc_Misra_Rule_9_Lint=Note 929: cast from pointer to pointer [MISRA 2004 Rule 11.4]
Doc_Misra_Rule_9_Reason=See detailed description for particular component
Doc_Misra_Rule_9_Type=Required
DriverAuthor=Petr Cach
DriverDate=04.12.2006
DriverVersion=01.01
EndOfInterface=
Settings=Common\PE_TypesSettings.inc
Doc_Misra_Rule_10_Location=[Cpu|AsynchroSerial|ADC|Cpu|AsynchroSerial|ADC|Cpu|AsynchroSerial|ADC|Cpu|AsynchroSerial|ADC|Cpu|AsynchroSerial|ADC]
Doc_Misra_Rule_10_Location_Reason=[In Device Initialization for RS08 derivatives that supports interrupt vector, in ISR dispatcher two status register are scanned in one while condition using || operator. Short evaluation of a condition is not important, because the ISR dispatcher scans the variables in the loop.|The code is accessing two volatile varibles in a condition. The order of access to variables is not important, because the variables are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|The code is accessing a register and a volatile varible in a condition. The order of access is not important, because the variable and register are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|In Device Initialization for RS08 derivatives that supports interrupt vector, in ISR dispatcher two status register are scanned in one while condition using || operator. Short evaluation of a condition is not important, because the ISR dispatcher scans the variables in the loop.|The code is accessing two volatile varibles in a condition. The order of access to variables is not important, because the variables are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|The code is accessing a register and a volatile varible in a condition. The order of access is not important, because the variable and register are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|In Device Initialization for RS08 derivatives that supports interrupt vector, in ISR dispatcher two status register are scanned in one while condition using || operator. Short evaluation of a condition is not important, because the ISR dispatcher scans the variables in the loop.|The code is accessing two volatile varibles in a condition. The order of access to variables is not important, because the variables are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|The code is accessing a register and a volatile varible in a condition. The order of access is not important, because the variable and register are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|In Device Initialization for RS08 derivatives that supports interrupt vector, in ISR dispatcher two status register are scanned in one while condition using || operator. Short evaluation of a condition is not important, because the ISR dispatcher scans the variables in the loop.|The code is accessing two volatile varibles in a condition. The order of access to variables is not important, because the variables are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|The code is accessing a register and a volatile varible in a condition. The order of access is not important, because the variable and register are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|In Device Initialization for RS08 derivatives that supports interrupt vector, in ISR dispatcher two status register are scanned in one while condition using || operator. Short evaluation of a condition is not important, because the ISR dispatcher scans the variables in the loop.|The code is accessing two volatile varibles in a condition. The order of access to variables is not important, because the variables are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.|The code is accessing a register and a volatile varible in a condition. The order of access is not important, because the variable and register are not mutualy dependent. Short evaluation of the condition is not importatnt in this case.]
Doc_Misra_Rule_11_Location=[Global|WatchDog|Global|WatchDog|Global|WatchDog|Global|WatchDog|Global|WatchDog]
Doc_Misra_Rule_11_Location_Reason=[Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled for 'Generate macros = yes' option (Build Options)|Comma operator is used in 'Clear' macro (optimization for code size). The rule is disabled for 'Generate macros = no' option (Build Options)|Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled for 'Generate macros = yes' option (Build Options)|Comma operator is used in 'Clear' macro (optimization for code size). The rule is disabled for 'Generate macros = no' option (Build Options)|Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled for 'Generate macros = yes' option (Build Options)|Comma operator is used in 'Clear' macro (optimization for code size). The rule is disabled for 'Generate macros = no' option (Build Options)|Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled for 'Generate macros = yes' option (Build Options)|Comma operator is used in 'Clear' macro (optimization for code size). The rule is disabled for 'Generate macros = no' option (Build Options)|Comma operator is used in macros for simple methods (optimization for code size). The rule is globally disabled for 'Generate macros = yes' option (Build Options)|Comma operator is used in 'Clear' macro (optimization for code size). The rule is disabled for 'Generate macros = no' option (Build Options)]
Doc_Misra_Rule_12_Location=[Cpu|SW_I2C|InternalI2C|Init_SAW|Cpu|SW_I2C|InternalI2C|Init_SAW|Cpu|SW_I2C|InternalI2C|Init_SAW|Cpu|SW_I2C|InternalI2C|Init_SAW|Cpu|SW_I2C|InternalI2C|Init_SAW]
Doc_Misra_Rule_12_Location_Reason=[PC-lint reports the warning for 'Delay100US' method, which is a wrapper for inline asm block (asm block is ignored by PC-lint);<br/>PC-lint may report the warning in Device Initialization for RS08 derivatives that supports interrupt vector. In interrupt service routine, empty sub-routines templates for each peripheral interrupt are called.|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay100US' method, which is a wrapper for inline asm block (asm block is ignored by PC-lint);<br/>PC-lint may report the warning in Device Initialization for RS08 derivatives that supports interrupt vector. In interrupt service routine, empty sub-routines templates for each peripheral interrupt are called.|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay100US' method, which is a wrapper for inline asm block (asm block is ignored by PC-lint);<br/>PC-lint may report the warning in Device Initialization for RS08 derivatives that supports interrupt vector. In interrupt service routine, empty sub-routines templates for each peripheral interrupt are called.|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay100US' method, which is a wrapper for inline asm block (asm block is ignored by PC-lint);<br/>PC-lint may report the warning in Device Initialization for RS08 derivatives that supports interrupt vector. In interrupt service routine, empty sub-routines templates for each peripheral interrupt are called.|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay100US' method, which is a wrapper for inline asm block (asm block is ignored by PC-lint);<br/>PC-lint may report the warning in Device Initialization for RS08 derivatives that supports interrupt vector. In interrupt service routine, empty sub-routines templates for each peripheral interrupt are called.|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).|PC-lint reports the warning for 'Delay' function, which is a wrapper for inline asm block (asm block is ignored by PC-lint).]
Doc_Misra_Rule_13_Location=[PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h]
Doc_Misra_Rule_14_Location=[Global|Global|Global|Global|Global]
Doc_Misra_Rule_15_Location=[IntFlash|IntFlash|IntFlash|IntFlash|IntFlash]
Doc_Misra_Rule_15_Location_Reason=['Source' parameter of SetBlockFlash method can be declared as const but only in specific component's setting (Write method = Write or Safe write). User interface should be uniform for all settings of the component, that's why 'const' is not used.|'Source' parameter of SetBlockFlash method can be declared as const but only in specific component's setting (Write method = Write or Safe write). User interface should be uniform for all settings of the component, that's why 'const' is not used.|'Source' parameter of SetBlockFlash method can be declared as const but only in specific component's setting (Write method = Write or Safe write). User interface should be uniform for all settings of the component, that's why 'const' is not used.|'Source' parameter of SetBlockFlash method can be declared as const but only in specific component's setting (Write method = Write or Safe write). User interface should be uniform for all settings of the component, that's why 'const' is not used.|'Source' parameter of SetBlockFlash method can be declared as const but only in specific component's setting (Write method = Write or Safe write). User interface should be uniform for all settings of the component, that's why 'const' is not used.]
Doc_Misra_Rule_16_Location=[ExtInt|ExtInt|ExtInt|ExtInt|ExtInt]
Doc_Misra_Rule_17_Location=[IO_Map.h|PE_Types.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|FreescaleCAN|IntFLASH|PE_Timer|PPG|PWM|PWMMC|SynchroMaster|SynchroSlave|IO_Map.h|PE_Types.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|FreescaleCAN|IntFLASH|PE_Timer|PPG|PWM|PWMMC|SynchroMaster|SynchroSlave|IO_Map.h|PE_Types.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|FreescaleCAN|IntFLASH|PE_Timer|PPG|PWM|PWMMC|SynchroMaster|SynchroSlave|IO_Map.h|PE_Types.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|FreescaleCAN|IntFLASH|PE_Timer|PPG|PWM|PWMMC|SynchroMaster|SynchroSlave|IO_Map.h|PE_Types.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|FreescaleCAN|IntFLASH|PE_Timer|PPG|PWM|PWMMC|SynchroMaster|SynchroSlave]
Doc_Misra_Rule_18_Location=[Global|Cpu|IO_Map.h|PE_Types.h|LCD|ExtInt|IntFlash|WatchDog|PE_Timer|AsynchroMaster|Global|Cpu|IO_Map.h|PE_Types.h|LCD|ExtInt|IntFlash|WatchDog|PE_Timer|AsynchroMaster|Global|Cpu|IO_Map.h|PE_Types.h|LCD|ExtInt|IntFlash|WatchDog|PE_Timer|AsynchroMaster|Global|Cpu|IO_Map.h|PE_Types.h|LCD|ExtInt|IntFlash|WatchDog|PE_Timer|AsynchroMaster|Global|Cpu|IO_Map.h|PE_Types.h|LCD|ExtInt|IntFlash|WatchDog|PE_Timer|AsynchroMaster]
Doc_Misra_Rule_18_Location_Reason=[Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros = yes' option (Build Options).|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: GetPllLockStatusFlag, GetLowVoltageFlag, SetStopMode, SetWaitMode, DisableInt, EnableInt, GetSpeedMode|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: __RESET_WATCHDOG|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: All macros for register access, __DI, __EI, EnterCritical, ExitCritical, SaveStatusReg, RestoreStatusReg, PE_DEBUGHALT, ISR|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: SetPixel, GetPixel|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Enable, Disable,GetVal|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Busy, EnableEvent, DisableEvent|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Clear|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macros: LngHi5|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: Standby, LoopMode, SetDirection, TurnRxOff, TurnRxOn, TurnTxOff, TurnTxOn, GetTxComplete|Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros = yes' option (Build Options).|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: GetPllLockStatusFlag, GetLowVoltageFlag, SetStopMode, SetWaitMode, DisableInt, EnableInt, GetSpeedMode|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: __RESET_WATCHDOG|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: All macros for register access, __DI, __EI, EnterCritical, ExitCritical, SaveStatusReg, RestoreStatusReg, PE_DEBUGHALT, ISR|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: SetPixel, GetPixel|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Enable, Disable,GetVal|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Busy, EnableEvent, DisableEvent|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Clear|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macros: LngHi5|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: Standby, LoopMode, SetDirection, TurnRxOff, TurnRxOn, TurnTxOff, TurnTxOn, GetTxComplete|Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros = yes' option (Build Options).|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: GetPllLockStatusFlag, GetLowVoltageFlag, SetStopMode, SetWaitMode, DisableInt, EnableInt, GetSpeedMode|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: __RESET_WATCHDOG|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: All macros for register access, __DI, __EI, EnterCritical, ExitCritical, SaveStatusReg, RestoreStatusReg, PE_DEBUGHALT, ISR|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: SetPixel, GetPixel|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Enable, Disable,GetVal|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Busy, EnableEvent, DisableEvent|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Clear|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macros: LngHi5|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: Standby, LoopMode, SetDirection, TurnRxOff, TurnRxOn, TurnTxOff, TurnTxOn, GetTxComplete|Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros = yes' option (Build Options).|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: GetPllLockStatusFlag, GetLowVoltageFlag, SetStopMode, SetWaitMode, DisableInt, EnableInt, GetSpeedMode|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: __RESET_WATCHDOG|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: All macros for register access, __DI, __EI, EnterCritical, ExitCritical, SaveStatusReg, RestoreStatusReg, PE_DEBUGHALT, ISR|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: SetPixel, GetPixel|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Enable, Disable,GetVal|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Busy, EnableEvent, DisableEvent|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Clear|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macros: LngHi5|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: Standby, LoopMode, SetDirection, TurnRxOff, TurnRxOn, TurnTxOff, TurnTxOn, GetTxComplete|Macros are used to optimize simple methods for code size. The rule is globally disabled for 'Generate macros = yes' option (Build Options).|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: GetPllLockStatusFlag, GetLowVoltageFlag, SetStopMode, SetWaitMode, DisableInt, EnableInt, GetSpeedMode|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: __RESET_WATCHDOG|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: All macros for register access, __DI, __EI, EnterCritical, ExitCritical, SaveStatusReg, RestoreStatusReg, PE_DEBUGHALT, ISR|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: SetPixel, GetPixel|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Enable, Disable,GetVal|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Busy, EnableEvent, DisableEvent|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macro: Clear|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following macros: LngHi5|Macros are used to optimize simple methods for code size. The rule is disabled for 'Generate macros = no' option (Build Options) for following methods: Standby, LoopMode, SetDirection, TurnRxOff, TurnRxOn, TurnTxOff, TurnTxOn, GetTxComplete]
Doc_Misra_Rule_19_Location=[PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h]
Doc_Misra_Rule_1_Location=[Global|PE_Types.h|IO_Map.h|Vectors.c|Cpu|IntFlash|IntEEPROM|SW_I2C|Init_SAW|InternalI2C|AsynchroSerial|BitIO|FreescaleAnalogComp|Init_IRTC|Init_PRACMP|ExtInt|Global|PE_Types.h|IO_Map.h|Vectors.c|Cpu|IntFlash|IntEEPROM|SW_I2C|Init_SAW|InternalI2C|AsynchroSerial|BitIO|FreescaleAnalogComp|Init_IRTC|Init_PRACMP|ExtInt|Global|PE_Types.h|IO_Map.h|Vectors.c|Cpu|IntFlash|IntEEPROM|SW_I2C|Init_SAW|InternalI2C|AsynchroSerial|BitIO|FreescaleAnalogComp|Init_IRTC|Init_PRACMP|ExtInt|Global|PE_Types.h|IO_Map.h|Vectors.c|Cpu|IntFlash|IntEEPROM|SW_I2C|Init_SAW|InternalI2C|AsynchroSerial|BitIO|FreescaleAnalogComp|Init_IRTC|Init_PRACMP|ExtInt|Global|PE_Types.h|IO_Map.h|Vectors.c|Cpu|IntFlash|IntEEPROM|SW_I2C|Init_SAW|InternalI2C|AsynchroSerial|BitIO|FreescaleAnalogComp|Init_IRTC|Init_PRACMP|ExtInt]
Doc_Misra_Rule_1_Location_ExtInt=[||||]
Doc_Misra_Rule_1_Location_Reason=[All components may contain one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|All components may contain one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|All components may contain one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|All components may contain one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|All components may contain one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.]
Doc_Misra_Rule_20_Location=[PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h|PE_Types.h]
Doc_Misra_Rule_20_Location_Reason=[Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.|Used to convert bit name to bit mask in macros accessing registers.]
Doc_Misra_Rule_21_Location=[Global|Global|Global|Global|Global]
Doc_Misra_Rule_2_Location=[Cpu|ADC|PE_Cnvrt.c|MeasurementEngine|IntFlash|Byte2IO|Byte3IO|Byte4IO|IntEEPROM|Cpu|ADC|PE_Cnvrt.c|MeasurementEngine|IntFlash|Byte2IO|Byte3IO|Byte4IO|IntEEPROM|Cpu|ADC|PE_Cnvrt.c|MeasurementEngine|IntFlash|Byte2IO|Byte3IO|Byte4IO|IntEEPROM|Cpu|ADC|PE_Cnvrt.c|MeasurementEngine|IntFlash|Byte2IO|Byte3IO|Byte4IO|IntEEPROM|Cpu|ADC|PE_Cnvrt.c|MeasurementEngine|IntFlash|Byte2IO|Byte3IO|Byte4IO|IntEEPROM]
Doc_Misra_Rule_2_Location_Lint=[Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Note 931: Both sides have side effects [MISRA 2004 Rule 1.2]|Info 740: Unusual pointer cast (incompatible indirect types) [MISRA 2004 Rule 1.2]]
Doc_Misra_Rule_2_Location_Reason=[When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to function.|PC-Lint reports for summing of the calibration registers values by Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|PC-Lint reports for operations with status variables (EnChan, EnChanFlags, ChRun). The variables are declared as volatile, but the order of variables access is not important, because the variables are not mutualy dependent.|PC-Lint reports for summing of the calibration registers values by ADC_Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to function.|PC-Lint reports for summing of the calibration registers values by Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|PC-Lint reports for operations with status variables (EnChan, EnChanFlags, ChRun). The variables are declared as volatile, but the order of variables access is not important, because the variables are not mutualy dependent.|PC-Lint reports for summing of the calibration registers values by ADC_Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to function.|PC-Lint reports for summing of the calibration registers values by Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|PC-Lint reports for operations with status variables (EnChan, EnChanFlags, ChRun). The variables are declared as volatile, but the order of variables access is not important, because the variables are not mutualy dependent.|PC-Lint reports for summing of the calibration registers values by ADC_Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to function.|PC-Lint reports for summing of the calibration registers values by Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|PC-Lint reports for operations with status variables (EnChan, EnChanFlags, ChRun). The variables are declared as volatile, but the order of variables access is not important, because the variables are not mutualy dependent.|PC-Lint reports for summing of the calibration registers values by ADC_Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to function.|PC-Lint reports for summing of the calibration registers values by Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|PC-Lint reports for operations with status variables (EnChan, EnChanFlags, ChRun). The variables are declared as volatile, but the order of variables access is not important, because the variables are not mutualy dependent.|PC-Lint reports for summing of the calibration registers values by ADC_Calibrate method. The variable in header file for access to each calibration register is declared as volatile, but the order of register access is not important for setting the gain registers, because the registers used for summing are not changed after the automatic calibration end.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|PC-Lint reports for reading the input value by GetVal method from several ports. The variable in header file for access to each port register is declared as volatile, but the order of register access is not important (neglected) for IO access.|When writing to FLASH memory, the routine waiting for write operation completion is copied to RAM memory and run in the RAM memory. Pointer cast of the wait routine is used for copy of the routine to the RAM memory.]
Doc_Misra_Rule_3_Location=[Global|Global|Global|Global|Global]
Doc_Misra_Rule_4_Location=[IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h|IO_Map.h]
Doc_Misra_Rule_5_Location=[IO_Map.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|SynchroMaster|SynchroSlave|PWMMC|SPI2UART|IO_Map.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|SynchroMaster|SynchroSlave|PWMMC|SPI2UART|IO_Map.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|SynchroMaster|SynchroSlave|PWMMC|SPI2UART|IO_Map.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|SynchroMaster|SynchroSlave|PWMMC|SPI2UART|IO_Map.h|AsynchroSerial|AsynchroMaster|AsynchroSlave|SynchroMaster|SynchroSlave|PWMMC|SPI2UART]
Doc_Misra_Rule_6_Location=[Cpu|Cpu|Cpu|Cpu|Cpu]
Doc_Misra_Rule_7_Location=[RTC|RTC|RTC|RTC|RTC]
Doc_Misra_Rule_8_Location=[Cpu|IntFlash|Init_SAW|IntEEPROM|Cpu|IntFlash|Init_SAW|IntEEPROM|Cpu|IntFlash|Init_SAW|IntEEPROM|Cpu|IntFlash|Init_SAW|IntEEPROM|Cpu|IntFlash|Init_SAW|IntEEPROM]
Doc_Misra_Rule_8_Location_Reason=[Internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer;<br/> When Interrupt vector table is generated into RAM, pointers to ISR functions are initialized by typecast of an integral value to the function pointer type. Typecast from pointer to integral type is also used in SetIntVect method when checking parameter value;<br/>SetBackdoorKey method uses typecast from pointer to integral to pass parameter to high level inline assembly routine placed in RAM.<br/> In interrupt vector table in Device Initialization, unassigned ISR are initialized by typecast of an integral value to the function pointer type.|Driver writing to FLASH memory uses pointer type for accessing data in the memory and integer type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|SAW internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer.|Driver for D-Flash memory type writing to EEPROM memory uses pointer type for accessing data in the memory and integral type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|Internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer;<br/> When Interrupt vector table is generated into RAM, pointers to ISR functions are initialized by typecast of an integral value to the function pointer type. Typecast from pointer to integral type is also used in SetIntVect method when checking parameter value;<br/>SetBackdoorKey method uses typecast from pointer to integral to pass parameter to high level inline assembly routine placed in RAM.<br/> In interrupt vector table in Device Initialization, unassigned ISR are initialized by typecast of an integral value to the function pointer type.|Driver writing to FLASH memory uses pointer type for accessing data in the memory and integer type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|SAW internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer.|Driver for D-Flash memory type writing to EEPROM memory uses pointer type for accessing data in the memory and integral type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|Internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer;<br/> When Interrupt vector table is generated into RAM, pointers to ISR functions are initialized by typecast of an integral value to the function pointer type. Typecast from pointer to integral type is also used in SetIntVect method when checking parameter value;<br/>SetBackdoorKey method uses typecast from pointer to integral to pass parameter to high level inline assembly routine placed in RAM.<br/> In interrupt vector table in Device Initialization, unassigned ISR are initialized by typecast of an integral value to the function pointer type.|Driver writing to FLASH memory uses pointer type for accessing data in the memory and integer type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|SAW internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer.|Driver for D-Flash memory type writing to EEPROM memory uses pointer type for accessing data in the memory and integral type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|Internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer;<br/> When Interrupt vector table is generated into RAM, pointers to ISR functions are initialized by typecast of an integral value to the function pointer type. Typecast from pointer to integral type is also used in SetIntVect method when checking parameter value;<br/>SetBackdoorKey method uses typecast from pointer to integral to pass parameter to high level inline assembly routine placed in RAM.<br/> In interrupt vector table in Device Initialization, unassigned ISR are initialized by typecast of an integral value to the function pointer type.|Driver writing to FLASH memory uses pointer type for accessing data in the memory and integer type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|SAW internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer.|Driver for D-Flash memory type writing to EEPROM memory uses pointer type for accessing data in the memory and integral type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|Internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer;<br/> When Interrupt vector table is generated into RAM, pointers to ISR functions are initialized by typecast of an integral value to the function pointer type. Typecast from pointer to integral type is also used in SetIntVect method when checking parameter value;<br/>SetBackdoorKey method uses typecast from pointer to integral to pass parameter to high level inline assembly routine placed in RAM.<br/> In interrupt vector table in Device Initialization, unassigned ISR are initialized by typecast of an integral value to the function pointer type.|Driver writing to FLASH memory uses pointer type for accessing data in the memory and integer type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.|SAW internal oscillator trim register is initialized by typecasting storage address of a trim value to the pointer.|Driver for D-Flash memory type writing to EEPROM memory uses pointer type for accessing data in the memory and integral type for manipulation and storage of the address to memory. Conversion between both types is needed and performed by the typecast between integral type and pointer type.]
Doc_Misra_Rule_9_Location=[Cpu|Term|IntFlash|ADC|PE_Cnvrt.c|Capture|MeasurementEngine|IntEEPROM|PWMMC|Cpu|Term|IntFlash|ADC|PE_Cnvrt.c|Capture|MeasurementEngine|IntEEPROM|PWMMC|Cpu|Term|IntFlash|ADC|PE_Cnvrt.c|Capture|MeasurementEngine|IntEEPROM|PWMMC|Cpu|Term|IntFlash|ADC|PE_Cnvrt.c|Capture|MeasurementEngine|IntEEPROM|PWMMC|Cpu|Term|IntFlash|ADC|PE_Cnvrt.c|Capture|MeasurementEngine|IntEEPROM|PWMMC]
Doc_Misra_Rule_9_Location_Reason=[When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to a function.|Conversion between pointer to char type and pointer to unsigned char type is used in ReadChar method to receive characters.|When writing to FLASH memory, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>When Virtual page is enabled, it's possible to write or read a byte, a word or a double word to or from Virtual page (GetBytePage, SetBytePage, GetWordPage, SetWordPage, GetLongPage and SetLongPage methods). Pointer cast of the Virtual Page array to the desired type is used in these methods.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|Typecast between pointers is used in GetCaptureValue method in case, it is generated as a macro.|Typecast between pointers is used when an array of pointers is accessed, which contains register addresses.|The EEPROM peripheral module (D-Flash memory type) works with two data bytes (word) for write operation, but access to one byte is needed (GetByte, SetByte methods). Conversion between the pointer to byte and pointer to word is used and typecast for pointer arithmetic is used.|Typecast between pointers is used in SetRatio16 method for ratio calculation.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to a function.|Conversion between pointer to char type and pointer to unsigned char type is used in ReadChar method to receive characters.|When writing to FLASH memory, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>When Virtual page is enabled, it's possible to write or read a byte, a word or a double word to or from Virtual page (GetBytePage, SetBytePage, GetWordPage, SetWordPage, GetLongPage and SetLongPage methods). Pointer cast of the Virtual Page array to the desired type is used in these methods.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|Typecast between pointers is used in GetCaptureValue method in case, it is generated as a macro.|Typecast between pointers is used when an array of pointers is accessed, which contains register addresses.|The EEPROM peripheral module (D-Flash memory type) works with two data bytes (word) for write operation, but access to one byte is needed (GetByte, SetByte methods). Conversion between the pointer to byte and pointer to word is used and typecast for pointer arithmetic is used.|Typecast between pointers is used in SetRatio16 method for ratio calculation.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to a function.|Conversion between pointer to char type and pointer to unsigned char type is used in ReadChar method to receive characters.|When writing to FLASH memory, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>When Virtual page is enabled, it's possible to write or read a byte, a word or a double word to or from Virtual page (GetBytePage, SetBytePage, GetWordPage, SetWordPage, GetLongPage and SetLongPage methods). Pointer cast of the Virtual Page array to the desired type is used in these methods.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|Typecast between pointers is used in GetCaptureValue method in case, it is generated as a macro.|Typecast between pointers is used when an array of pointers is accessed, which contains register addresses.|The EEPROM peripheral module (D-Flash memory type) works with two data bytes (word) for write operation, but access to one byte is needed (GetByte, SetByte methods). Conversion between the pointer to byte and pointer to word is used and typecast for pointer arithmetic is used.|Typecast between pointers is used in SetRatio16 method for ratio calculation.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to a function.|Conversion between pointer to char type and pointer to unsigned char type is used in ReadChar method to receive characters.|When writing to FLASH memory, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>When Virtual page is enabled, it's possible to write or read a byte, a word or a double word to or from Virtual page (GetBytePage, SetBytePage, GetWordPage, SetWordPage, GetLongPage and SetLongPage methods). Pointer cast of the Virtual Page array to the desired type is used in these methods.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|Typecast between pointers is used in GetCaptureValue method in case, it is generated as a macro.|Typecast between pointers is used when an array of pointers is accessed, which contains register addresses.|The EEPROM peripheral module (D-Flash memory type) works with two data bytes (word) for write operation, but access to one byte is needed (GetByte, SetByte methods). Conversion between the pointer to byte and pointer to word is used and typecast for pointer arithmetic is used.|Typecast between pointers is used in SetRatio16 method for ratio calculation.|When writing to FLASH memory in SetBackdoorKey method, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast of the routine is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>In the interrupt vector table in Device Initialization for ColdFire V1 derivatives, stack pointer is initialized by typecast of a pointer to the pointer to a function.|Conversion between pointer to char type and pointer to unsigned char type is used in ReadChar method to receive characters.|When writing to FLASH memory, the routine performing the write operation is copied to RAM memory and run in the RAM memory. Pointer cast is used for copy of the routine to the RAM memory and for call of the routine in RAM.;<br/>When Virtual page is enabled, it's possible to write or read a byte, a word or a double word to or from Virtual page (GetBytePage, SetBytePage, GetWordPage, SetWordPage, GetLongPage and SetLongPage methods). Pointer cast of the Virtual Page array to the desired type is used in these methods.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|To ensure the high byte of the 16.bit result register is read first, both bytes are read separately and joined using the typecast to pointer to a structure.|Typecast between pointers is used in GetCaptureValue method in case, it is generated as a macro.|Typecast between pointers is used when an array of pointers is accessed, which contains register addresses.|The EEPROM peripheral module (D-Flash memory type) works with two data bytes (word) for write operation, but access to one byte is needed (GetByte, SetByte methods). Conversion between the pointer to byte and pointer to word is used and typecast for pointer arithmetic is used.|Typecast between pointers is used in SetRatio16 method for ratio calculation.]
PE_MisraErrorBackCodes=[sym(960,14.3)]
PE_MisraErrorCodes=[sym(960,14.3)]
revAuth=[MS]
revCmnt_0=[char_t and TPE_Float typedefs added|Obsolete macros input, output, in16, out16 removed]
revDate=[15.07.2010]
revLvl=[5]
revVer=[01.01]
revVrf=[RH]

 LOCAL SYMBOLS (alphabet order)
-------------------------------
DeviceModule=PE_Types
DeviceName=PE_Types
DeviceType=PE_Types
EventModules=[Events]
ModuleName=PE_Types

GLOBAL SYMBOLS (alphabet order)
-------------------------------
ADCAsynchroClockAddr=4294934550
ADCAsynchroClockReg=ADCCFG
ADCBusClockAddr=4294934550
ADCBusClockReg=ADCCFG
ADCClkSelAddr=4294934550
ADCClkSelReg=ADCCFG
ADCConstPrescAddr=4294934550
ADCConstPrescReg=ADCCFG
ActiveConfigIdentifier=PEcfg_Release_51QE128CLH
ActiveConfiguration=Release_51QE128CLH
BDIVAddr=4294934585
BDIVReg=ICSC2
COPBusClkPrescAddr=4294940674
COPBusClkPrescReg=SOPT1
COPClkSelAddr=4294940675
COPClkSelReg=SOPT2
COPIntClkPrescAddr=4294940674
COPIntClkPrescReg=SOPT1
CPUDB_CW_MCU_ID=28672
CPUDB_CW_MCU_NAME=MCF51QE128
CPUDB_Flash_EraseSectorSize=1024
CPUDB_Flash_NumOfBlocks=1
CPUDB_LQFP64=-1
CPUDB_MCF51QE128=-1
CPUDB_PACKAGE=LQFP64
CPU_DB_version=3.00.080
CPUendian=big
CPUfamily=ColdFireV1
CPUproducer=Freescale
CPUrunSpeedModeNum=1
CPUsubFamily=MCF51QE
CPUtype=MCF51QE128_64
CPUvariant=MCF51QE128CLH
C_FAR_MOD=
C_GenMacros=yes
ClientDir_Binary=F:\Proyectos\Robot-QE128\Sources\
ClientDir_Code=F:\Proyectos\Robot-QE128\Generated_Code\
ClientDir_PE=C:\Freescale\CW MCU v10.3\MCU\ProcessorExpert\
ClientDir_Project=F:\Proyectos\Robot-QE128\
CommentBrackets=/**/
Compiler=CodeWarriorColdFireV1
CompilerID=CodeWarrior ColdFireV1 C Compiler
DirRel_Binary=Sources\
DirRel_BinaryToEvents=
DirRel_Code=Generated_Code\
DirRel_Docs=Documentation\
DirRel_EventToBinary=
DirRel_Events=Sources\
DirRel_ProjectSettings=Project_Settings\
EclipseProjectName=Robot-QE128
FLLClkSelAddr=4294934587
FLLClkSelReg=ICSSC
FLL_32kHzAddr=4294934587
FLL_32kHzReg=ICSSC
FLL_DefaultAddr=4294934587
FLL_DefaultReg=ICSSC
HighClock_kHz=33
HighClock_kHz_real=32.768
HighSpeedClock=Internal Clock
High_TPM3=
IO_Map_WatchDogResetMethod=WriteAny
IO_Map_WatchDogServiceRegister=SRS
InterruptTableType=ROM
Language=ANSIC
Not_for_MPC512x=
Not_for_MPC5500_MCF=
O_PIB_full_Init=no
OnChipEEPROM=0
OnChipFLASH=131072
OnChipRAM=8192
PE_DEVELOPMENT=
PE_ECLIPSE=
PE_GENERATING=
PE_G_CRI_CPUENABLE_set0_TPM3SC=16
PE_G_CRI_CPUENABLE_set1_TPM3SC=8
PE_G_CRI_CPUINIT_set0_PTAD=0
PE_G_CRI_CPUINIT_set0_PTADD=12
PE_G_CRI_CPUINIT_set0_PTAPE=12
PE_G_CRI_CPUINIT_set0_PTBD=0
PE_G_CRI_CPUINIT_set0_PTBDD=1
PE_G_CRI_CPUINIT_set0_PTCD=10
PE_G_CRI_CPUINIT_set0_PTCDD=0
PE_G_CRI_CPUINIT_set0_PTCPE=0
PE_G_CRI_CPUINIT_set1_PTAD=0
PE_G_CRI_CPUINIT_set1_PTADD=0
PE_G_CRI_CPUINIT_set1_PTAPE=0
PE_G_CRI_CPUINIT_set1_PTBD=2
PE_G_CRI_CPUINIT_set1_PTBDD=2
PE_G_CRI_CPUINIT_set1_PTCD=5
PE_G_CRI_CPUINIT_set1_PTCDD=15
PE_G_CRI_CPUINIT_set1_PTCPE=10
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_set0_TPM3SC=0
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_set1_TPM3SC=8
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set0_TPM3CNTH=255
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set0_TPM3SC=255
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set1_TPM3CNTH=0
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set1_TPM3SC=0
PE_G_MisraCnfBackParams_0=
PE_G_MisraCnfBackParams_1=
PE_G_MisraCnfParams_0=
PE_G_MisraCnfParams_1=
PE_G_MisraRuleList_0=
PE_G_MisraRuleList_1=
PE_G_MisraStackIdx=-1
PE_ProductVersion=10.0
PEversion=05.03
PEversionDecimal=1283
ProcessorModule=Cpu
ProcessorName=Cpu
ProjectModule=ProcessorExpert
ProjectName=ProcessorExpert
RDIVAddr=4294934584
RDIVReg=ICSC1
RTCExtClkAddr=4294940720
RTCExtClkReg=RTCSC
RTCIntClkAddr=4294940720
RTCIntClkReg=RTCSC
RTCIntOscAddr=4294940720
RTCIntOscReg=RTCSC
ServerDir_PE=C:\Freescale\CW MCU v10.3\MCU\ProcessorExpert\
SetHighSpeedMode=Internal Clock
SupportedCPUfamily=
TimeStamp=2013-04-23, 06:54, # CodeGen: 67
VirtualTPM1PrescAddr=4294934592
VirtualTPM1PrescReg=TPM1SC
VirtualTPM2PrescAddr=4294934608
VirtualTPM2PrescReg=TPM2SC
VirtualTPM3PrescAddr=4294934624
VirtualTPM3PrescReg=TPM3SC
Xtal_kHz=0
Xtal_kHz_real=0
ivVsci1err=Terminal_InterruptError
ivVsci1rx=Terminal_InterruptRx
ivVsci1tx=Terminal_InterruptTx
ivVtpm1ch0=OSTimerTickISR
ivVtrap14=OSSyscallISR

 DEPRECATED GLOBAL SYMBOLS (alphabet order)
-------------------------------------------
ADCAsynchroClockAddr=null
ADCAsynchroClockReg=null
ADCBusClockAddr=null
ADCBusClockReg=null
ADCClkSelAddr=null
ADCClkSelReg=null
ADCConstPrescAddr=null
ADCConstPrescReg=null
ActiveConfigIdentifier=null
ActiveConfiguration=null
BDIVAddr=null
BDIVReg=null
COPBusClkPrescAddr=null
COPBusClkPrescReg=null
COPClkSelAddr=null
COPClkSelReg=null
COPIntClkPrescAddr=null
COPIntClkPrescReg=null
CPUDB_CW_MCU_ID=null
CPUDB_CW_MCU_NAME=null
CPUDB_Flash_EraseSectorSize=null
CPUDB_Flash_NumOfBlocks=null
CPUDB_LQFP64=null
CPUDB_MCF51QE128=null
CPUDB_PACKAGE=null
CPU_DB_version=null
CPUendian=null
CPUfamily=null
CPUproducer=null
CPUrunSpeedModeNum=null
CPUsubFamily=null
CPUtype=null
CPUvariant=null
C_FAR_MOD=null
C_GenMacros=null
ClientDir_Binary=null
ClientDir_Code=null
ClientDir_PE=null
ClientDir_Project=null
CommentBrackets=null
Compiler=null
CompilerID=null
DirRel_Binary=null
DirRel_BinaryToEvents=null
DirRel_Code=null
DirRel_Docs=null
DirRel_EventToBinary=null
DirRel_Events=null
DirRel_ProjectSettings=null
EclipseProjectName=null
FLLClkSelAddr=null
FLLClkSelReg=null
FLL_32kHzAddr=null
FLL_32kHzReg=null
FLL_DefaultAddr=null
FLL_DefaultReg=null
HighClock_kHz=null
HighClock_kHz_real=null
HighSpeedClock=null
High_TPM3=null
IO_Map_WatchDogResetMethod=null
IO_Map_WatchDogServiceRegister=null
InterruptTableType=null
Language=null
Not_for_MPC512x=null
Not_for_MPC5500_MCF=null
O_PIB_full_Init=null
OnChipEEPROM=null
OnChipFLASH=null
OnChipRAM=null
PE_DEVELOPMENT=null
PE_ECLIPSE=null
PE_GENERATING=null
PE_G_CRI_CPUENABLE_set0_TPM3SC=null
PE_G_CRI_CPUENABLE_set1_TPM3SC=null
PE_G_CRI_CPUINIT_set0_PTAD=null
PE_G_CRI_CPUINIT_set0_PTADD=null
PE_G_CRI_CPUINIT_set0_PTAPE=null
PE_G_CRI_CPUINIT_set0_PTBD=null
PE_G_CRI_CPUINIT_set0_PTBDD=null
PE_G_CRI_CPUINIT_set0_PTCD=null
PE_G_CRI_CPUINIT_set0_PTCDD=null
PE_G_CRI_CPUINIT_set0_PTCPE=null
PE_G_CRI_CPUINIT_set1_PTAD=null
PE_G_CRI_CPUINIT_set1_PTADD=null
PE_G_CRI_CPUINIT_set1_PTAPE=null
PE_G_CRI_CPUINIT_set1_PTBD=null
PE_G_CRI_CPUINIT_set1_PTBDD=null
PE_G_CRI_CPUINIT_set1_PTCD=null
PE_G_CRI_CPUINIT_set1_PTCDD=null
PE_G_CRI_CPUINIT_set1_PTCPE=null
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_set0_TPM3SC=null
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_set1_TPM3SC=null
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set0_TPM3CNTH=null
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set0_TPM3SC=null
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set1_TPM3CNTH=null
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_set1_TPM3SC=null
PE_G_MisraCnfBackParams_0=null
PE_G_MisraCnfBackParams_1=null
PE_G_MisraCnfParams_0=null
PE_G_MisraCnfParams_1=null
PE_G_MisraRuleList_0=null
PE_G_MisraRuleList_1=null
PE_G_MisraStackIdx=null
PE_ProductVersion=null
PEversion=null
PEversionDecimal=null
ProcessorModule=null
ProcessorName=null
ProjectModule=null
ProjectName=null
RDIVAddr=null
RDIVReg=null
RTCExtClkAddr=null
RTCExtClkReg=null
RTCIntClkAddr=null
RTCIntClkReg=null
RTCIntOscAddr=null
RTCIntOscReg=null
ServerDir_PE=null
SetHighSpeedMode=null
SupportedCPUfamily=null
TimeStamp=null
VirtualTPM1PrescAddr=null
VirtualTPM1PrescReg=null
VirtualTPM2PrescAddr=null
VirtualTPM2PrescReg=null
VirtualTPM3PrescAddr=null
VirtualTPM3PrescReg=null
Xtal_kHz=null
Xtal_kHz_real=null
ivVsci1err=null
ivVsci1rx=null
ivVsci1tx=null
ivVtpm1ch0=null
ivVtrap14=null

 GLOBAL LISTS (alphabet order)
-------------------------------------------
ADCAsynchroClock=[1|undef|undef]
ADCAsynchroClock_Setting=[1|undef|undef]
ADCBusClock=[1|undef|undef]
ADCBusClock_Setting=[1|undef|undef]
ADCClkSel=[1|undef|undef]
ADCClkSel_Setting=[ADCBusClock|undef|undef]
ADCConstPresc=[20|undef|undef]
ADCConstPresc_Setting=[20|undef|undef]
BDIV=[1|undef|undef]
BDIV_Setting=[1|undef|undef]
CLKClkSel=[1|undef|undef]
CLKClkSel_Setting=[FLLClkSel|undef|undef]
COPBusClkPresc=[8192|undef|undef]
COPBusClkPresc_Setting=[8192|undef|undef]
COPClkSel=[1|undef|undef]
COPClkSel_Setting=[COPIntClkPresc|undef|undef]
COPIntClkPresc=[32|undef|undef]
COPIntClkPresc_Setting=[32|undef|undef]
CPUsystem_ticks=[0|undef|undef]
EventModuleList=[Events]
FLLClkSel=[1|undef|undef]
FLLClkSel_Setting=[FLL_Default|undef|undef]
FLL_32kHz=[608|undef|undef]
FLL_32kHz_Setting=[608|undef|undef]
FLL_Default=[1536|undef|undef]
FLL_Default_Setting=[1536|undef|undef]
IREFSClkSel=[1|undef|undef]
IREFSClkSel_Setting=[IREFSIntClk|undef|undef]
IncludeSharedModules=[PE_Types|PE_Error|PE_Const|IO_Map|PE_Timer]
InstructionClock=[25.165824|undef|undef]
ModuleList=[IV1|IV2|MotorD1|MotorD2|MotorI1|MotorI2|Terminal|Encoders]
PE_G_CRI_CPUENABLE_RegList8=[TPM3SC]
PE_G_CRI_CPUINIT_RegList8=[PTCDD|PTCD|PTCPE|PTBDD|PTBD|PTAD|PTAPE|PTADD]
PE_G_CRI_CPUINIT_prev_PTADD=[PTAD]
PE_G_CRI_CPUINIT_prev_PTBDD=[ PTBD]
PE_G_CRI_CPUINIT_prev_PTCDD=[PTCD|PTCD]
PE_G_CRI_CPUSPEEDINIT_AFTER_HIGH_RegList8=[TPM3SC]
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_RegList8=[TPM3SC|TPM3CNTH]
PE_G_CRI_CPUSPEEDINIT_BEFORE_HIGH_prev_TPM3CNTH=[TPM3SC|TPM3SC]
PE_Timer=[LngMul|LngHi3|LngHi2]
ProjectSharedModulesC=[IO_Map|PE_Timer]
RDIV=[undef|undef|undef]
RDIV_Setting=[undef|undef|undef]
RTCClkSel=[1|undef|undef]
RTCClkSel_Setting=[RTCIntClk|undef|undef]
RTCExtClk=[undef|undef|undef]
RTCExtClk_Setting=[undef|undef|undef]
RTCIntClk=[1|undef|undef]
RTCIntClk_Setting=[1|undef|undef]
RTCIntOsc=[1|undef|undef]
RTCIntOsc_Setting=[1|undef|undef]
SharedModules=[ColdFireV1\PE_Types.drv|ColdFireV1\PE_Error.drv|ColdFireV1\PE_Const.drv|ColdFireV1\IO_Map.drv|HCS08\PE_Timer.drv]
SpeedModeInitAfterNames=[AFTER_HIGH|AFTER_LOW|AFTER_SLOW]
SpeedModeInitBeforeNames=[BEFORE_HIGH|BEFORE_LOW|BEFORE_SLOW]
SpeedModeNames=[High|Low|Slow]
SystemPrescaler=[1|undef|undef]
SystemPrescaler_Setting=[1|undef|undef]
TPM1ClkSel=[1|undef|undef]
TPM1ClkSel_Setting=[TPM1BusClk|undef|undef]
TPM2ClkSel=[1|undef|undef]
TPM2ClkSel_Setting=[TPM2BusClk|undef|undef]
TPM3ClkSel=[1|undef|undef]
TPM3ClkSel_Setting=[TPM3BusClk|undef|undef]
VirtualTPM1Presc=[1|undef|undef]
VirtualTPM1Presc_Setting=[1|undef|undef]
VirtualTPM2Presc=[1|undef|undef]
VirtualTPM2Presc_Setting=[1|undef|undef]
VirtualTPM3Presc=[1|undef|undef]
VirtualTPM3Presc_Setting=[1|undef|undef]

{{DEVELOPMENT}} --------(((DEBUGINFO)))--------.{{DEVELOPMENT}} 

